

construct_chains := function (certificates) {
    local subj_to_num, num_to_cert, chains, duplicates;
    subj_to_num := dict ();
    num_to_cert := dict ();

    res := dict ();
    res.chains <- [];
    res.incomplete_chains <- [];
    res.duplicates <- [];
    res.unused <- [];

    if ! certificates then
        output (stderr, "construct_chains called with an empty list.\n");
        flush (stderr);
        return
    fi;

    register_cert := function (i, cert) {
        res.unused <- i::(res.unused);
        certs_with_the_same_subject := map (dget (num_to_cert), dget_all (subj_to_num, cert.tbs.subject.short));
        if cert in certs_with_the_same_subject then
            res.duplicates <- i::(res.duplicates);
            output (stderr, "Certificate $i is a duplicate\n");
            flush (stderr);
        else
            dadd (subj_to_num, cert.tbs.subject.short, i);
            dadd (num_to_cert, i, cert);
        fi;
    };

    iteri (register_cert, certificates);

    check_issuer_of := function (subject, i) {
        local issuer, ski, aki, bc;
        issuer := dget (num_to_cert, i);

        if subject.tbs.issuer != issuer.tbs.subject then return false fi;

        bc := issuer.get_extension ("basicConstraints");
        if (issuer.effective_version >= 3) &&
            ((! bc) || (! (exists bc.content.CA)) || (! bc.content.CA))
        then
            output (stderr, "Certificate $i should be a CA\n");
            flush (stderr);
            return false;
        fi;

        aki := subject.get_extension ("authorityKeyIdentifier");

        if (aki) then
            if (exists aki.content.keyIdentifier) then
                 ski := issuer.get_extension ("subjectKeyIdentifier");                 
                 if ski && ski.content != aki.content.keyIdentifier then return false fi;
                 // TODO: Could a SKI be absent in this case ?
            fi;
            if (exists aki.content.authorityCertSerialNumber) &&
                aki.content.authorityCertSerialNumber != issuer.tbs.serial
            then
                return false
            fi;
            // TODO: authorityCertIssuer
        fi;

        // TODO: Check signature

        return true;
    };

    find_issuers := function (s) {
        local subject, probable_issuers;
        subject := dget (num_to_cert, s);
        probable_issuers := dget_all (subj_to_num, subject.tbs.issuer.short);
        filter (check_issuer_of (subject), probable_issuers);
    };

    is_self_signed := function (i) {
        local cert, ski, aki;
        cert := dget (num_to_cert, i);

        if cert.tbs.subject != cert.tbs.issuer then return false fi;

        aki := cert.get_extension ("authorityKeyIdentifier");

        if (aki) then
            if (exists aki.content.keyIdentifier) then
                 ski := cert.get_extension ("subjectKeyIdentifier");
                 if ski && ski.content != aki.content.keyIdentifier then return false fi;
            fi;
            if (exists aki.content.authorityCertSerialNumber) &&
                aki.content.authorityCertSerialNumber != cert.tbs.serial
            then
                return false
            fi;
            // TODO: authorityCertIssuer
        fi;

        // TODO: Check signature

        return true;
    };

    // TODO: Check PathLen

    construct := function (accu, current) {
        local current_chain;
	current_chain:= current::accu;

        if (is_self_signed (current))
        then
            res.chains <- (current_chain)::(res.chains);
            res.unused <- filter (function (x) { ! (x in current_chain) }, res.unused);
        else
            local issuers;
            issuers := filter (function (x) { ! (x in current_chain) }, find_issuers (current));
            if issuers
            then map (construct (current_chain), issuers)
            else
                res.incomplete_chains <- (current_chain)::(res.incomplete_chains);
                res.unused <- filter (function (x) { ! (x in current_chain) }, res.unused);
            fi
        fi
    };

    construct ([], 0);
    res
};
