Critical
 - Bug on SKE which is not deep-parsed anymore.
 - Finalize the Makefile (make install)

v0.2 (feb. 2013 -> apr. 2013)
 - Use a standard format for printing data (JSON?)
 - Docs
   * Document the preprocessor (update the JFLA article)
   * Write index.txt for all subdirs
 - General
   * have a redmine to put all this stuff
   * clean up TODOs in ml files.
 - TlsEngine
   * work on TlsEngine.update* functions
   * write the automata (client, server, transparent proxy, normalizing proxy)
   * add a automaton_state field in context
   * add a check_consistency field in context
   * add a generic update function relying on the context and the message received to
     + check the consistency if necessary
     + update the state
     + return what to do next?
   * add another generic function with hooks for after each message / alert / appdata / ccs / heartbeat
   * Move test_answerDump.split_record in TlsUtil?
   * Clean up code in Tls and TlsEngine
   * [?] add a function "process_in : tls_record Lwt_mvar t -> tls_context -> tls_record Lwt_mvar t" which tries and aggregates messages, enrich handshakes and put one by record. When compression/cryptography works, it will also take that into account.
   * [?] add a function "process_out" to compress/mac/encrypt and slice in records of the correct length.
   * put 'a result_type and handle_answer logic from probe_server into TlsEngine
 - X509
   * Code construct_chains/check_chains in caml
     + add decoration directly to the certificate object (origin[s], trust)?
     + x509_chain should be an object module
       - list of decorated certs (trust, origin [Mozilla store, cert n in chain])
       - global attributes (enriched by check/chains with args [laxist, trusted store])
     + Low level functions
       - prepare_candidates (H : DN hashes -> certs)
       - find_next_candidate (H, current, options [use KI?])
       - check_link (subject, issuer)
     + Chain construction (chain up until now + pool of available certs [chain + trusted certs + untrusted certs])
       - avoid loops!
     + Chain checks (which can take trusted certificate stores to decorate the chain object)
       - validity span
       - check subject/issuer (+ *UniqueIdentifiers?)
       - signature
       - is there a trusted cert in the chain constructed
       - algos used
       - SKI/AKI could be relaxed (Applications are not required to verify that key identifiers match when performing certification path validation)
       - BC/
       - functions to check usage/name of the chain
       - use SAN/AIA/CRLDP/KU/EKU/NameConstraints or shout if a critical extension is not yet parsed
     + TLS chain construction -> use construct_chain with different stores (untrusted, MS, FF)
     + TLS chain analysis -> nCerts, nDupes, nUnused, nChains [+ characterisation]
     + Graph construction (From a big pool of certs, try to create all the links...)
   * Add a way to create a certificate object
 - Tools
   * bgpdump and/or obsdump
   * x509check (enrich the x509 object before analysing!)
   * chaincheck
   * check_sslserver (see check_sslserver.ml for a complete TODO)
   * Create simple PKI tools to create a RSA key, sign, verify, encrypt, decrypt, handle a simple PKI (rsa tool)
   * Write acu (AceSL Cert Util) to read certs / pubkeys / privkeys and manipulate them
   * Passive TLS_Proxy

 - General
   * Think about the exception system (fatal or not) => merge all in ParsifalException
   * add a field "handle_non_lethal_exceptions" to *_input (a function that could be raise or prerr_endline)
   * Improve the printing systems
     + do we need a hookable string_of function?
 - Software Engineering
   * Write some tests (unit tests, non-regression [for X.509 for example], coverage test, etc.)
   * Write .mli files
 - Camlp4/Language
   * rethink parse_params / dump_params (for now, the latter is only use for enumerated_bitstring)
   * rethink the exhaustive/enrich options for unions/asn1_unions
     + *dont_enrich* (enrich_ var) / enrich (enrich_ var) / force_enrich
     + <standard> / force_exhaustive (exhaustive + fail_hard) -> force_enrich / exhaustive / fail_soft (fail_on_enrich var + emit warning) 
   * add control commands in struct (check / seek / stop)
   * be more cautious about int32 types...
   * add hex_container / gzip_container as custom containers
   * improve basic get functions
   * improve get_wrapper (raw, gzip, base64, etc.)
   * add {,} to get path language (x.{y,z}.{t,a})
   * improve get on asn1_alias (for example, it does not add the outter sequence of a certificate)
   * Implement the parse_check function (the result could be OK | Fail | StopEnrich (continue but do not enrich the following stuff))
   * Add a "flexible" decorator in structures
       -> try to parse or if it fails, parse with ~enrich:false (it would only be effective on union, but it still counts)
       -> add another one to have "flexible-like field : type" turned into "field : | Either type | Or binstring" ?
       -> Apply it to MP_REACH_NLRI in Mrt.
   * Add recursive type definitions (PKCS#7 / DEX)
   * Add bitfield support
     + this should look like struct
     + it should use bitparse_ / bitdump_ functions, that take two more args (current_byte, current_pos)
     + enums should offer bitparse and bitdump funs
 - Tls
   * use record check functions to constrain a binrec (length of 2^14 in TlsRecord)
   * Add SSLv2 support in probe_server and other programs
   * Implement every extension/PK present in ssl-data
 - X509
   * other extensions: 2.16.840.1.113730.1.1 (NSCertType), 2.16.840.1.113730.1.13 (NSComment)
   * relax constraints to allow parsing
   * Add support for CSR
   * OCSP and CRL parsers
 - Crypto
   * Write test_pkcs1 to check RSA implementation
   * Look at the code of cryptokit which seems groovy
   * Simplify the RSA code (to avoid the useless creation of a key object)
   * Add support for DSA
   * Merge PKCS#1 and RSAKey?
   * Think about the bigint (Big_int, Cryptokit, or stg else?)
 - Tools
   * probe_server: Add an option to extract the certificates presented
   * probe_server: Add a way to handle TLS extensions
   * x509compare
   * Begin a GUI for PKI tools
   * crlshow / crlcompare
   * a tool to re-sign a modified certificate (given you have the adequate private key of course)
   * Add a general config directory, modifiable by cmdline, by general config file and by local config file (which could contain a directory of OIds)
   * s_client
   * Active TLS_Proxy
   * Ajouter liens dgst <- sha1sum
   * dgst : options (-quiet, -hex, -check, -file + args / ou stdin)
   * Gestion du temps passé (man 2 times) et ajout de barres de progression
   * servercheck
   * clientcheck
 - Write some tests to check in browsers
   * certificates with extensions containing images
   * certificates signing each other (A <-> B)
 - PKCS#11 client (prospective)
 - Misc
   * Add an option to customize the integer dump -> hexdump or hexdump_with_separator or hexdump_openssl_like
   * getopt tuning (help usage messages [principal and details], multiline descriptions)


v0.3 (jun. 2013)
 - Formats
   * Protobuf
   * PNG
 - Camlp4/language
   * Auto-generate parsers in C/python/? with an option (c_parser, python_parser)?
   * Generate dump2protobuf for structs?
 - X509
   * add popular extensions (1.2.840.113549.1.9.15 : sMIMECapabilities; 1.3.6.1.5.5.7.1.12 : logoType)
   * Add a test to really check if the idempotence was broken!
 - Tools
   * s_server
 - PKCS#11 ressource (prospective)
 - Parsifal
   * Add options to skip dump/print/parse generation with structures


v1.0 (oct 2013)
 - Software Engineering
   * Document everything (ocamldoc or doxygen)
   * unit tests for everything
 - Tools which should be usable
   * asn1parse
   * x509
   * rsa
   * pki
   * tlsparse
   * s_client
   * s_server
   * tls_proxy
 - Crypto
   * ECC (see seccure project)
   * Shamir Secret Sharing (see ssss project)



Offer the same services as NSS/openssl:
 - SSLv2/SSLv3/TLSv1/TLSv1.1/TLSv1.2
 - PKCS#1 #3 #5 #7 #8 #9 #10 #11 #12
 - S/MIME
 - X.509v3/OCSP/CRL
 - RSA/DSA/ECDSA/DH/ECDH/AES/3DES/DES/RC2/RC4/SHA1/SHA2/MD2/MD5/HMAC
 - PRNG


Checks on certs / chains
 - if S.AKI is absent but I.SKI is present
 - if S.AKI is present but I.AKI is not


Long Term... it could also be moved upstairs...

- Encoding
  * 2022 -> Simple ASCII (NumericString, PrintableString, VisibleString, IA5String)
  * 2022 (T61String, VideotexString, GraphicString, GeneralString)
  * 10646 / Unicode (UniversalString, BMPString, UTF8String)
