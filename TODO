v0.2 (apr. 2013)
 - Software Engineering
   * Write some tests (unit tests, non-regression [for X.509 for example], coverage test, etc.)
   * non-regression test on answer-type/ncerts
 - Investigate some oddities:
   * in 009-129, 129.79.24.188 was J(15030000120228dcbcea4df63e3abfbe) and became A(Fatal,HandshakeFailure)
   => Can an alert be split on two records? Two alerts grouped in one record?
   => OpenSSL says it must be 2 bytes long
   => GNUTLS says it must be at least 2 bytes long, and ignore the remaining bytes
   => Choose how to treat it in --answer-type
 - Merge tls_context and ssl2_context?
 - Misc
   * Factor som code (verbose option, file handling, action handling) in getopt
   * getopt tuning (help usage messages [principal and details], multiline descriptions)
   * getopt tuning (add constraint on the number of args?)
   * Add an option to customize the integer dump -> hexdump or hexdump_with_separator or hexdump_openssl_like
 - X509
   * add popular extensions
       2.16.840.1.113730.1.8 (nsCAPolicyURL)
       2.16.840.1.113719.1.9.4.1 (securityAttributes [Novell])
       1.3.6.1.4.1.3029.3.1.5 (keyFeatures)
 - Docs
   * Write a tutorial
     + Installation
     + First use (x509 / dns)
     + Creating support for new formats: tar, pcap
 - General
   * have a redmine to put all this stuff
   * clean up TODOs in ml files.
 - Tools
   * Write a cool passive TLS_Proxy
   * Add direct hex input to asn1parse and other programs
   * check_sslserver (see check_sslserver.ml for a complete TODO)
   * picodig (using a special sr function (send/receive)?)
   * rewrite server-answer with the following options
     -p port to bind
     -A alert to send (Fatal,HandshakeFailure)
     --versions (as in probe-certs)
     --ciphersuite
     --compression
     -c cert-file (add a cert)
     -S send server-hello message
     -C send certificate message
     -D send server-hello-done message
   * improve probe-server
     + add extract-cert feature
     + add SSLv2 support
     + add a way to handle TLS extensions
   * improve mapAnswers
     + add record_version to A/H answer types
     + add support for client_hello_sent in mapAnswers/answer_type?
     + add SSLv2 support in mapAnswers (especially -g)

v0.3 (may 2013)
 - Write a parse_XXXX_as_value (string_input/lwt_input -> value) which would keep the context (offset/len)
 - TlsEngine (work needed to factor code in mapAnswers and extractSessions properly)
   * work on TlsEngine.update* functions
   * write the automata (client, server, transparent proxy, normalizing proxy)
   * add a automaton_state field in context
   * add a check_consistency field in context
   * add a generic update function relying on the context and the message received to
     + check the consistency if necessary
     + update the state
     + return what to do next?
   * add another generic function with hooks for after each message / alert / appdata / ccs / heartbeat
   * Move mapAnswers.split_record in TlsUtil?
   * Clean up code in Tls and TlsEngine
   * [?] add a function "process_in : tls_record Lwt_mvar t -> tls_context -> tls_record Lwt_mvar t" which tries and aggregates messages, enrich handshakes and put one by record. When compression/cryptography works, it will also take that into account.
   * [?] add a function "process_out" to compress/mac/encrypt and slice in records of the correct length.
   * put 'a result_type and handle_answer logic from probe_server into TlsEngine
 - Write a trivial SSL client or server
 - Add .mli for all files!
 - Add a proper way to be flexible while parsing ATV/Extensions/Times (flexible option + laxist option in input)... because that is where the parsing fails (and it should by default!)
 - Add @dump in VRecord when an option is present in struct?
 - Design the language to explore values (functions like hex / dump / substring / asn1parse / M.parse one day and conditionnal expressions...)
 - Factor some code (lwt_parse_file filename lwt_parse_fun; the more common options (enrich, verbose, input handling); get machinery)
 - Use modules to aggregate the functions for some top-level objects (parse/dump/value_of)
 - Docs
   * Document the preprocessor and write a new version of the JFLA article. Comapre to existing stuff:
     + https://github.com/jaked/deriving
     + http://www.lexifi.com/blog/syntax-extensions-without-camlp4
     + http://code.google.com/p/bitstring/
     + Lex/Bison and Haskell's Parsec
     + Haskell's Binary?
     + Haskell's Templates?
   * Write index.txt for all subdirs
 - X509
   * Code construct_chains/check_chains in caml
     + add decoration directly to the certificate object (origin[s], trust)?
     + x509_chain should be an object module
       - list of decorated certs (trust, origin [Mozilla store, cert n in chain])
       - global attributes (enriched by check/chains with args [laxist, trusted store])
     + Low level functions
       - prepare_candidates (H : DN hashes -> certs)
       - find_next_candidate (H, current, options [use KI?])
       - check_link (subject, issuer)
     + Chain construction (chain up until now + pool of available certs [chain + trusted certs + untrusted certs])
       - avoid loops!
     + Chain checks (which can take trusted certificate stores to decorate the chain object)
       - validity span
       - check subject/issuer (+ *UniqueIdentifiers?)
       - signature
       - is there a trusted cert in the chain constructed
       - algos used
       - SKI/AKI could be relaxed (Applications are not required to verify that key identifiers match when performing certification path validation)
       - BC/
       - functions to check usage/name of the chain
       - use SAN/AIA/CRLDP/KU/EKU/NameConstraints or shout if a critical extension is not yet parsed
     + TLS chain construction -> use construct_chain with different stores (untrusted, MS, FF)
     + TLS chain analysis -> nCerts, nDupes, nUnused, nChains [+ characterisation]
     + Graph construction (From a big pool of certs, try to create all the links...)
   * Add a way to create a certificate object
 - Tools
   * bgpdump and/or obsdump
   * x509check (enrich the x509 object before analysing!)
   * chaincheck
   * Create simple PKI tools to create a RSA key, sign, verify, encrypt, decrypt, handle a simple PKI (rsa tool)
   * Write acu (AceSL Cert Util) to read certs / pubkeys / privkeys and manipulate them

 - General
   * Think about the exception system (fatal or not) => merge all in ParsifalException
 - Camlp4/Language
   * rethink the exhaustive/enrich options for unions/asn1_unions. The params are
     + Enrich status : always-enrich, enrich_by_default, dont_enrich_by_default (the last two add an enrich bool ref)
     + Exhaustive status : true or false
     + Fail status when enriching has failed : exception, unparsed_constructor
   * the possibilities should be:
     + "closed" => always-enrich, exception on "_" case
     + "closed" + "exhaustive" => do not add the "_" case
     + (default) => dont_enrich_by_default, exhaustive = false, on fail => let the exception go
     + options "enrich", "exhaustive", "soft_fail" to change the default
     + option "unparsed_type" to specify the type and remove the mandatory name?
   * Add SoftExceptions for enums (could be useful for content_type / alert_level)
   * add control commands in struct (check / seek / stop)
   * be more cautious about int32 types...
   * add hex_container / gzip_container as custom containers
   * improve get_wrapper (raw, gzip, base64, etc.)
   * add {,} to get path language (x.{y,z}.{t,a})
   * Implement the parse_check function (the result could be OK | Fail | StopEnrich (continue but do not enrich the following stuff))
   * Add a "flexible" decorator in structures
       -> try to parse or if it fails, parse with ~enrich:false (it would only be effective on union, but it still counts)
       -> add another one to have "flexible-like field : type" turned into "field : | Either type | Or binstring" ?
       -> Apply it to MP_REACH_NLRI in Mrt.
   * Add recursive type definitions (PKCS#7 / DEX)
   * Add bitfield support
     + this should look like struct
     + it should use bitparse_ / bitdump_ functions, that take two more args (current_byte, current_pos)
     + enums should offer bitparse and bitdump funs
 - Tls
   * use record check functions to constrain a binrec (length of 2^14 in TlsRecord)
   * Implement every extension/PK present in ssl-data
 - X509
   * Add support for CSR
   * OCSP and CRL parsers
 - Crypto
   * Write test_pkcs1 to check RSA implementation
   * Look at the code of cryptokit which seems groovy
   * Simplify the RSA code (to avoid the useless creation of a key object)
   * Add support for DSA
   * Merge PKCS#1 and RSAKey?
   * Think about the bigint (Big_int, Cryptokit, or stg else?)
 - Tools
   * x509compare
   * Begin a GUI for PKI tools
   * crlshow / crlcompare
   * a tool to re-sign a modified certificate (given you have the adequate private key of course)
   * Add a general config directory, modifiable by cmdline, by general config file and by local config file (which could contain a directory of OIds)
   * s_client
   * Active TLS_Proxy
   * dgst : options (-quiet, -hex, -check, -file + args / ou stdin)
   * Gestion du temps passé (man 2 times) et ajout de barres de progression
   * servercheck
   * clientcheck
 - Write some tests to check in browsers
   * certificates with extensions containing images
   * certificates signing each other (A <-> B)
 - PKCS#11 client (prospective)


v0.4 (jun. 2013)
 - Have a cool way to handle parse/dump params using a new syntax
   * for now, dump_params are only use for enumerated_bitstring and in tar
   * a cool way would be (parse_param; Parse parse_param; Dump dump_params; Both both_params) => we could handle the order correctly
 - Add cool containers where it is possible to specify the real type ( (int, string) either / int option )
   => example : device_major in tar header?
 - Formats
   * Protobuf
   * PNG
 - Camlp4/language
   * Generate dump2protobuf for structs?
 - X509
   * Add a test to really check if the idempotence was broken!
 - Tools
   * s_server
 - PKCS#11 ressource (prospective)
 - Parsifal
   * Add options to skip parse/dump/value_of generation with structures


v1.0 (oct 2013)
 - Rewrite the type names/field names to be uniform (we must choose between camel case and underscores)
 - Cross-reference where each RFC is implemented (annotate the RFC and the code)
 - Software Engineering
   * Document everything (ocamldoc or doxygen)
   * unit tests for everything
 - Tools which should be usable
   * asn1parse
   * x509
   * rsa
   * pki
   * tlsparse
   * s_client
   * s_server
   * tls_proxy
 - Crypto
   * ECC (see seccure project)
   * Shamir Secret Sharing (see ssss project)



Offer the same services as NSS/openssl:
 - SSLv2/SSLv3/TLSv1/TLSv1.1/TLSv1.2
 - PKCS#1 #3 #5 #7 #8 #9 #10 #11 #12
 - S/MIME
 - X.509v3/OCSP/CRL
 - RSA/DSA/ECDSA/DH/ECDH/AES/3DES/DES/RC2/RC4/SHA1/SHA2/MD2/MD5/HMAC
 - PRNG


Checks on certs / chains
 - if S.AKI is absent but I.SKI is present
 - if S.AKI is present but I.AKI is not


Long Term... it could also be moved upstairs...

- Encoding
  * 2022 -> Simple ASCII (NumericString, PrintableString, VisibleString, IA5String)
  * 2022 (T61String, VideotexString, GraphicString, GeneralString)
  * 10646 / Unicode (UniversalString, BMPString, UTF8String)
