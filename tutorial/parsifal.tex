\documentclass{beamer}
\usetheme{anssi}
\usepackage[french]{babel}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{colortbl}
\usepackage{eso-pic}
\usepackage{longtable}
\usepackage{hhline}
\usepackage{fancyhdr}
\usepackage{pstricks}
\usepackage{pst-node}
\usepackage{pst-text}
\usepackage{etex}
\usepackage{tikz}
\usepackage{listings}
\lstset{language=Caml, basicstyle=\footnotesize,
  morekeywords={enum, alias, struct, union,
                asn1_alias,
                UnknownVal, with_lwt, Exception}}

\usetikzlibrary{arrows,shapes}


\begin{document}

\begin{frame}
  \mytitlepage{Parsifal: écriture rapide de \emph{parsers}}{}
  {Olivier Levillain}{ANSSI}{19 avril 2013}{fr}
\end{frame}

\usenavigation{yes}{4}{1}
\usepagenumbering{yes}
\setbeamertemplate{headline}[body]
\setbeamertemplate{footline}[body]
\title{Parsifal: écriture rapide de \textit{parsers}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Table des matières}
  \vspace{12mm}
  \tableofcontents
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contexte}

\begin{frame}{Table des matières}
  \vspace{12mm}
  \tableofcontents[currentsection]
\end{frame}

\begin{frame}{Point de départ: des mesures SSL (1/2)}
  \vspace{12mm}

  Campagnes de mesure SSL, réalisées entre juillet 2010 et juillet
  2011, selon le fonctionnement suivant:
  \begin{itemize}
  \item énumération des hôtes IPv4 avec un port 443 ouvert
  \item envoi d'un \texttt{ClientHello}
  \item récupération de la réponse du serveur
  \end{itemize}

  \bigskip

  \uncover<2->{\`A partir de 10~campagnes complètes, analyse de
    certains paramètres:
    \begin{itemize}
    \item paramètres TLS
    \item qualité de la chaîne de certification
    \item comportement du serveur face à différents stimuli
    \item \textit{publication à ACSAC 2012}
    \end{itemize}
  }
\end{frame}


\begin{frame}{Point de départ: des mesures SSL (2/2)}
  \vspace{12mm}

  L'objectif était d'extraire de ces 143~Go de données
  \begin{itemize}
  \item des données pertinentes (messages TLS reçus, certificats
    présentés)
  \item rapidement
  \item de manière robuste
  \end{itemize}

  \bigskip

  \uncover<2->{L'EFF, à l'origine d'une partie des données de l'étude,
    a également publié des analyses
    \begin{itemize}
    \item utilisation d'outils standards (\texttt{openssl})
    \item essentiellement focalisé sur les certificats
    \end{itemize}
  }
\end{frame}


\begin{frame}{Historique des outils}
  \vspace{12mm}

  Pour traiter ce volume de données, plusieurs implantations ont été développées
  \begin{itemize}
  \item<2-> premier prototype en Python: rapide à écrire, mais lent
  \item<3-> seconde version en C++ (avec \textit{templates} et des objets):
    \begin{itemize}
    \item assez flexible (langage de description)
    \item plus rapide, mais
    \item pénible à mettre au point (fuites mémoire, \emph{segfaults})
    \item nécessite trop de code pour ajouter des fonctionnalités
    \end{itemize}
  \item<4-> troisième version en OCaml (avec un DSL, \textit{Domain Specific Language} ressemblant à Python):
    \begin{itemize}
    \item rapide et flexible
    \item plus robuste que le précédent
    \item mais encore beaucoup trop de code à écrire
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Historique des outils (suite)}
  \vspace{12mm}

  \begin{itemize}
  \item quatrième version en OCaml, en utilisant un pré-processeur maison...
  \item<2-> très vite réécrit pour utiliser camlp4, une boîte à outils
    OCaml permettant (entre autres) d'écrire proprement des
    pré-processeurs
    \begin{itemize}
    \item code rapide, robuste, et très concis
    \item cette fois, tous les indicateurs sont au vert!
    \end{itemize}
  \end{itemize}

  \bigskip

  \uncover<2->{Le résultat s'appelle Parsifal
    \begin{itemize}
    \item voir Eric pour savoir comment Parsifal aurait aussi pu s'appeler
    \item soumission courte au SSTIC pour présenter Parsifal
    \item objectif: publication de la version 0.1 avant le SSTIC
    \end{itemize}
  }
\end{frame}


\begin{frame}{Quelques chiffres}
  \vspace{12mm}

  TODO

\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Démonstrations}

\begin{frame}{Table des matières}
  \vspace{12mm}
  \tableofcontents[currentsection]
\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Installation}

\begin{frame}{Table des matières}
  \vspace{12mm}
  \tableofcontents[currentsection]
\end{frame}





% \begin{frame}{Principe}
%   \vspace{12mm}

%   À partir de descriptions courtes des types, génération automatique
%   des éléments suivants:
%   \begin{itemize}
%   \item type OCaml \texttt{t}
%   \item fonction \texttt{parse\_t}
%   \item fonction \texttt{dump\_t}
%   \item fonction \texttt{print\_t}
%   \end{itemize}
% \end{frame}


% \begin{frame}[fragile]{Énumérations}
%   \vspace{12mm}

%   Objectif: bénéficier d'un type somme sans avoir à écrire les
%   fonctions de conversions vers les entiers

% {\footnotesize
% \begin{lstlisting}
% enum tls_version [with_lwt] (16, UnknownVal V_Unknown) =
%   | 0x0002 -> V_SSLv2, "SSLv2"
%   | 0x0300 -> V_SSLv3, "SSLv3"
%   | 0x0301 -> V_TLSv1, "TLSv1.0"
%   | 0x0302 -> V_TLSv1_1, "TLSv1.1"
%   | 0x0303 -> V_TLSv1_2, "TLSv1.2"
% \end{lstlisting}
% }

%   Éléments supplémentaires produits:
%   \begin{itemize}
%   \item \texttt{int\_of\_tls\_version}
%   \item \texttt{string\_of\_tls\_version}
%   \item \texttt{tls\_version\_of\_int}
%   \item \texttt{tls\_version\_of\_string}
%   \end{itemize}

% \end{frame}


% \begin{frame}[fragile]{Structures (1/2)}
%   \vspace{12mm}

%   Objectif: structure enchaînant des champs\\[.5cm]

%   Extrait de la RFC 5246 (TLSv1.2):
% {\footnotesize
% \begin{lstlisting}
% enum { warning(1), fatal(2), (255) } AlertLevel;

% enum {
%     close_notify(0),
%     unexpected_message(10),
%      ...
%     unsupported_extension(110),
%     (255)
% } AlertDescription;

% struct {
%     AlertLevel level;
%     AlertDescription description;
% } Alert;
% \end{lstlisting}
% }

% \end{frame}


% \begin{frame}[fragile]{Structures (2/2)}
%   \vspace{12mm}

% {\footnotesize
% \begin{lstlisting}
% enum tls_alert_level (8, UnknownVal AL_Unknown, []) =
%   | 1 -> AL_Warning, "Warning"
%   | 2 -> AL_Fatal, "Fatal"

% enum tls_alert_type (8, UnknownVal AT_Unknown, []) =
%   | 0 -> AT_CloseNotify, "CloseNotify"
%   | 10 -> AT_UnexpectedMessage, "UnexpectedMessage"
%     ...
%   | 110 -> AT_UnsupportedExtension, "UnsupportedExtension"

% struct tls_alert =
% {
%   alert_level : tls_alert_level;
%   alert_type : tls_alert_type
% }
% \end{lstlisting}
% }

% \end{frame}


% \begin{frame}[fragile]{Unions}
%   \vspace{12mm}

%   Objectif: en fonction d'un discriminant, produire un sous-type

% {\footnotesize
% \begin{lstlisting}
% union autonomous_system [enrich] (UnparsedAS) =
%   | 16 -> AS16 of uint16
%   | 32 -> AS32 of uint32

% struct bgp_as_path_segment [param as_size] =
% {
%   path_segment_type : uint8;
%   path_segment_length : uint8;
%   path_segment_value : list(path_segment_length) of
%                        autonomous_system(as_size)
% }
% \end{lstlisting}
% }

% \end{frame}


% \begin{frame}[fragile]{Alias}
%   \vspace{12mm}

% {\footnotesize
% \begin{lstlisting}
% alias ustar_magic = magic["ustar"]
% alias tar_file [with_lwt] = list of tar_entry;

% struct atv_content = {
%   attributeType : der_oid;
%   attributeValue : der_object
% }
% asn1_alias atv
% asn1_alias rdn = set_of atv  (* min = 1 *)
% asn1_alias distinguishedName = seq_of rdn
% \end{lstlisting}
% }

% \end{frame}


% \begin{frame}{Démo}
%   \vspace{12mm}

%   Démo des exemples précédents.

% \end{frame}

% \TODO{Ajouter du binaire et un schéma joli, éventuellement auto-généré?}

% \begin{frame}{Exemple complet: TAR}
%   \vspace{12mm}

%   Démo.

% \end{frame}


% \begin{frame}{Outils connexes}
%   \vspace{8mm}

%   \TODO{Scapy, Hachoir, Caml bitstring, autre truc cité par le mec des
%     JFLA}
% \end{frame}

% \begin{frame}{Formats et protocoles décrits à ce jour}
%   \vspace{12mm}

%   \begin{itemize}
%   \item X.509 (360~lignes)
%   \item TLS (800~lignes)
%   \item MRT+BGPg (360~lignes)
%   \item TAR (90~lignes)
%   \item PE (travail en cours par Pierre)
%   \item ExpROM (travail en cours par Pierre)
%   \item OCSP (travail en cours par Olivier)
%   \end{itemize}

% \end{frame}


% \begin{frame}{Formats et protocoles à venir}
%   \vspace{12mm}

%   \begin{itemize}
%   \item CRL
%   \item DNS
%   \item PCAP ?
%   \item Acid ?
%   \item AML ?
%   \item DEX ?
%   \item ELF ?
%   \end{itemize}

% \end{frame}


\begin{frame}{Questions ?}
  \vspace{30mm}

  \begin{center}
    Merci de votre attention.
  \end{center}

\end{frame}




\end{document}
