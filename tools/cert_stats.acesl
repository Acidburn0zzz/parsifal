#!/home/yeye/dev/FAceSL/facesl.native -f

parser.tolerance <- 4;
parser.minDisplay <- 4;
tls.parse_certificates <- true;


foreach_answer := function (f, path) {
    foreach (open (path), answer_dump.parse, f);
};      


count := 0;
with_certs := 0;
content_types := dict ();
samples := dict ();

add_sample := function (msg_types) {
    "(${dget_def (samples, msg_types, "???")})  \t" ++ msg_types
};

print_info := function () {
    print ();
    print (count, with_certs);
    print_stats (content_types, add_sample);
};

handle_answer := function (answer) {
    local msgs, msgs_certificates, certs, chains, category, prev_count;

    count := count + 1;

    msgs := tls.parse (answer.ip, answer.content);
    msgs_certificates := filter (function (x) { exists x.content.certificates }, msgs);
    if length (msgs_certificates) = 0 then return fi;
    if length (msgs_certificates) > 1 then
        output (stderr, "Answer ${answer.ip} contains more than one certificate message.")
    fi;
    certs := head (msgs_certificates).content.certificates;
    if (length (certs) = 0) then return fi;

    with_certs := with_certs + 1;
    chains := construct_chains (certs);
    category := "${length (certs)} certificate(s), ${length (chains.unused)} unused, of which ${length (chains.duplicates)} are duplicates. ${to_string (chains.chains)} ${to_string (chains.incomplete_chains)}";

    if single then print (answer.ip, category) fi;
 
    prev_count := dget_def (content_types, category, 0);
    if prev_count = 0 then dset (samples, category, answer.client_hello_type ++ ":" ++ answer.ip) fi;
    dset (content_types, category, prev_count + 1);

    if (freq && count % freq = 0) then print_info (); fi
};


single := exists getenv ("SINGLE");

if exists getenv ("FREQ") then
    freq := getenv ("FREQ");
else
    freq := 0;
fi;

map (foreach_answer (handle_answer), args);
print_info ();
