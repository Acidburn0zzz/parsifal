<!DOCTYPE HTML>
<html dir="ltr" lang="en-US"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>The SSL 0.2 Protocol</title>
</head><body>
<div id="outer-wrapper">
<div id="main" class="with-menu">
<div id="main-content">

<center>
<h2>
<font size="+3">SSL 0.2 P</font>ROTOCOL <font size="+3">S</font>PECIFICATION
</h2>
</center>

<hr size="4">

<p>
<b>
T<font size="-1">HIS</font> P<font size="-1">ROTOCOL</font>
S<font size="-1">PECIFICATION</font> W<font size="-1">AS</font>
R<font size="-1">EVISED</font> O<font size="-1">N</font>
N<font size="-1">OVEMBER</font> 29<font size="-1">TH,</font> 1994:
</b>
</p><p>

</p><ul>

<li>a fundamental correction to the client-certificate authentication
protocol,

</li><li>the removal of the username/password messages,

</li><li>corrections in some of the cryptographic terminology,

</li><li>the addition of a MAC to the messages [see section 1.2],

</li><li>the allowance for different kinds of message digest algorithms.

</li></ul>
<b>
T<font size="-1">HIS</font> D<font size="-1">OCUMENT</font> 
W<font size="-1">AS</font> R<font size="-1">EVISED</font>
O<font size="-1">N</font> D<font size="-1">ECEMBER</font>
22<font size="-1">ND,</font> 1994:
</b>
<p>


</p><ul>

<li>The spec now defines the order the clear key data and secret key
data are combined to produce the master key.

</li><li>The spec now explicitly states the size of the MAC instead of making
the reader figure it out.

</li><li>The spec is more clear on the actual values used to produce the
session read and write keys.

</li><li>The spec is more clear on how many bits of the session key are used
after they are produced from the hash function.

</li></ul>

<b>
T<font size="-1">HIS</font> D<font size="-1">OCUMENT</font>
W<font size="-1">AS</font> R<font size="-1">EVISED</font>
O<font size="-1">N</font> J<font size="-1">ANUARY</font>
17<font size="-1">TH,</font> 1995:
</b>
<p>

</p><ul>

<li>Defined the category to be informational.

</li><li>Clarified ordering of data elements in various places.

</li><li>Defined DES-CBC cipher kind and key construction.

</li><li>Defined DES-EDE3-CBC cipher kind and key construction.

</li></ul>

<b>
T<font size="-1">HIS</font> D<font size="-1">OCUMENT</font>
W<font size="-1">AS</font> R<font size="-1">EVISED</font>
O<font size="-1">N</font> J<font size="-1">ANUARY</font>
24<font size="-1">TH,</font> 1995:
</b>
<p>

</p><ul>

<li>Fixed bug in definition of <tt>CIPHER-CHOICE</tt> in
<tt>CLIENT-MASTER-KEY</tt> message. The previous spec erroneously
indicated that the <tt>CIPHER-CHOICE</tt> was an index into the
servers <tt>CIPHER-SPECS-DATA</tt> array, when it was actually
supposed to be the <tt>CIPHER-KIND</tt> value chosen by the client.

</li><li>Clarified the values of the <tt>KEY-ARG-DATA</tt>.

</li></ul>
<b>
T<font size="-1">HIS</font> D<font size="-1">OCUMENT</font>
W<font size="-1">AS</font> R<font size="-1">EVISED</font>
O<font size="-1">N</font> F<font size="-1">EBRUARY</font>
9<font size="-1">TH,</font> 1995:
</b>
<p>


</p><ul>The spec has been clarified to indicate the byte order of sequence
numbers when they are being applied to the MAC hash function.

<li>The spec now defines the acceptable length range of the
<tt>CONNECTION-ID</tt> parameter (sent by the server in the
<tt>SERVER-HELLO</tt> message).

</li><li>Simplified the specification of the <tt>CIPHER-KIND</tt> data.
The spec language has been changed yet the format remains compatible
with all existing implementations. The <tt>CIPHER-KIND</tt>
information is now a three byte value which defines the type of cipher
and the length of the key. The key length is no longer separable from
the <tt>CIPHER-KIND</tt>.

</li><li>Explained how the <tt>KEY-ARG-DATA</tt> is retained with the
<tt>SESSION-ID</tt> when the session-identifier cache is used.

</li></ul>

<hr size="8">

<pre>Experimental                                             Kipp E.B. Hickman
Request For Comments: XXXX                   Netscape Communications Corp.
Category: Informational                        Last Update: Feb. 9th, 1995
</pre>

<p>

</p><center>The SSL Protocol</center> <p>

</p><h3>Status of this Memo</h3>
<dl>
<dd> 
This is a <b>DRAFT</b> specification. <p>

This RFC specifies a security protocol for the Internet community, and
requests discussion and suggestions for improvements. Distribution of
this memo is unlimited.

</p></dd></dl>
<h3>Abstract</h3>
<dl><dd>

This document specifies the Secure Sockets Layer (SSL) protocol, a
security protocol that provides privacy over the Internet. The
protocol allows client/server applications to communicate in a way
that cannot be eavesdropped. Server's are always authenticated and
clients are optionally authenticated. <p>

</p></dd></dl>
<h3>Motivation</h3>
<dl><dd>

The SSL Protocol is designed to provide privacy between two
communicating applications (a client and a server). Second, the
protocol is designed to authenticate the server, and optionally the
client. SSL requires a reliable transport protocol (e.g. TCP) for data
transmission and reception. <p>

The advantage of the SSL Protocol is that it is application protocol
independent. A "higher level" application protocol (e.g. HTTP, FTP,
TELNET, etc.) can layer on top of the SSL Protocol transparently.  The
SSL Protocol can negotiate an encryption algorithm and session key as
well as authenticate a server before the application protocol
transmits or receives its first byte of data. All of the application
protocol data is transmitted encrypted, ensuring privacy. </p><p>

The SSL protocol provides "channel security" which has three basic
properties: </p><p>

</p><ul type="disc">

<li>The channel is private. Encryption is used for all messages after
a simple handshake is used to define a secret key. <p>

</p></li><li>The channel is authenticated. The server endpoint of the
conversation is always authenticated, while the client endpoint is
optionally authenticated. <p>

</p></li><li>The channel is reliable. The message transport includes a message
integrity check (using a MAC).

</li></ul>

</dd></dl>
<h3>1. SSL Record Protocol Specification</h3>
<dl><dd>

<h4>1.1 SSL Record Header Format</h4>

In SSL, all data sent is encapsulated in a <b>record</b>, an object
which is composed of a header and some non-zero amount of data.  Each
record header contains a two or three byte length code.  If the most
significant bit is set in the first byte of the record length code
then the record has no padding and the total header length will be 2
bytes, otherwise the record has padding and the total header length
will be 3 bytes. The record header is transmitted before the data
portion of the record. <p>

Note that in the long header case (3 bytes total), the second most
significant bit in the first byte has special meaning. When zero, the
record being sent is a data record. When one, the record being sent is
a security escape (there are currently no examples of security
escapes; this is reserved for future versions of the protocol). In
either case, the length code describes how much data is in the record.
</p><p>

The record length code does not include the number of bytes consumed
by the record header (2 or 3). For the 2 byte header, the record
length is computed by (using a "C"-like notation): </p><p>

</p><pre>RECORD-LENGTH = ((byte[0] &amp; 0x7f) &lt;&lt; 8)) | byte[1];
</pre>

Where byte[0] represents the first byte received and byte[1] the
second byte received.  When the 3 byte header is used, the record
length is computed as follows (using a "C"-like notation): <p>

</p><pre>RECORD-LENGTH = ((byte[0] &amp; 0x3f) &lt;&lt; 8)) | byte[1];
IS-ESCAPE = (byte[0] &amp; 0x40) != 0;
PADDING = byte[2];
</pre>

The record header defines a value called <tt>PADDING</tt>. The
<tt>PADDING</tt> value specifies how many bytes of data were appended
to the original record by the sender. The padding data is used to make
the record length be a multiple of the block ciphers block size when a
block cipher is used for encryption. <p>

The sender of a "padded" record appends the padding data to the end of
its normal data and then encrypts the total amount (which is now a
multiple of the block cipher's block size). The actual value of the
padding data is unimportant, but the encrypted form of it must be
transmitted for the receiver to properly decrypt the record. Once the
total amount being transmitted is known the header can be properly
constructed with the <tt>PADDING</tt> value set appropriately. </p><p>

The receiver of a padded record decrypts the entire record data (sans
record length and the optional padding) to get the clear data, then
subtracts the <tt>PADDING</tt> value from the <tt>RECORD-LENGTH</tt>
to determine the final <tt>RECORD-LENGTH</tt>. The clear form of the
padding data must be discarded. </p><p>

</p><h4>1.2 SSL Record Data Format</h4>

The data portion of an SSL record is composed of three components
(transmitted and received in the order shown): <p>

</p><pre>MAC-DATA[MAC-SIZE]
ACTUAL-DATA[N]
PADDING-DATA[PADDING]
</pre>

<tt>ACTUAL-DATA</tt> is the actual data being transmitted (the message
payload). <tt>PADDING-DATA</tt> is the padding data sent when a block
cipher is used and padding is needed. Finally, <tt>MAC-DATA</tt> is
the <i>Message Authentication Code</i>. <p>

When SSL records are sent in the clear, no cipher is used.
Consequently the amount of <tt>PADDING-DATA</tt> will be zero and the
amount of <tt>MAC-DATA</tt> will be zero. When encryption is in
effect, the <tt>PADDING-DATA</tt> will be a function of the cipher
block size. The <tt>MAC-DATA</tt> is a function of the
<tt>CIPHER-CHOICE</tt> (more about that later). </p><p>

The <tt>MAC-DATA</tt> is computed as follows: </p><p>

</p><pre>MAC-DATA = HASH[ SECRET, ACTUAL-DATA, PADDING-DATA, SEQUENCE-NUMBER ]
</pre>

Where the <tt>SECRET</tt> data is fed to the hash function first,
followed by the <tt>ACTUAL-DATA</tt>, which is followed by the
<tt>PADDING-DATA</tt> which is finally followed by the
<tt>SEQUENCE-NUMBER</tt>. The <tt>SEQUENCE-NUMBER</tt> is a 32 bit
value which is presented to the hash function as four bytes, with the
first byte being the most significant byte of the sequence number, the
second byte being the next most significant byte of the sequence
number, the third byte being the third most significant byte, and the
fourth byte being the least significant byte (that is, in network byte
order or "big endian" order).  <p>

<tt>MAC-SIZE</tt> is a function of the digest algorithm being
used. For MD2 and MD5 the <tt>MAC-SIZE</tt> will be 16 bytes (128
bits). </p><p>

The <tt>SECRET</tt> value is a function of which party is sending the
message. If the client is sending the message then the <tt>SECRET</tt>
is the <tt>CLIENT-WRITE-KEY</tt> (the server will use the
<tt>SERVER-READ-KEY</tt> to verify the MAC). If the client is
receiving the message then the <tt>SECRET</tt> is the
<tt>CLIENT-READ-KEY</tt> (the server will use the
<tt>SERVER-WRITE-KEY</tt> to generate the MAC). </p><p>

The <tt>SEQUENCE-NUMBER</tt> is a counter which is incremented by both
the sender and the receiver. For each transmission direction, a pair
of counters is kept (one by the sender, one by the receiver). Every
time a message is sent by a sender the counter is incremented.
Sequence numbers are 32 bit unsigned quantities and must wrap to zero
after incrementing past 0xFFFFFFFF. </p><p>

The receiver of a message uses the expected value of the sequence
number as input into the MAC <tt>HASH</tt> function (the <tt>HASH</tt>
function is chosen from the <tt>CIPHER-CHOICE</tt>). The computed
<tt>MAC-DATA</tt> must agree bit for bit with the transmitted
<tt>MAC-DATA</tt>. If the comparison is not identity then the record
is considered damaged, and it is to be treated as if an "I/O Error"
had occurred (i.e. an unrecoverable error is asserted and the
connection is closed). </p><p>

A final consistency check is done when a block cipher is used and the
protocol is using encryption. The amount of data present in a record
(<tt>RECORD-LENGTH)</tt>)must be a multiple of the cipher's block
size.  If the received record is not a multiple of the cipher's block
size then the record is considered damaged, and it is to be treated as
if an "I/O Error" had occurred (i.e. an unrecoverable error is asserted
and the connection is closed). </p><p>

The SSL Record Layer is used for all SSL communications, including
handshake messages, security escapes and application data
transfers. The SSL Record Layer is used by both the client and the
server at all times. </p><p>

For a two byte header, the maximum record length is 32767 bytes.  For
the three byte header, the maximum record length is 16383 bytes. The
SSL Handshake Protocol messages are constrained to fit in a single SSL
Record Protocol record. Application protocol messages are allowed to
consume multiple SSL Record Protocol record's. </p><p>

Before the first record is sent using SSL all sequence numbers are
initialized to zero. The transmit sequence number is incremented after
every message sent, starting with the <tt>CLIENT-HELLO</tt> and
<tt>SERVER-HELLO</tt> messages. </p><p>

</p></dd></dl>
<h3>2. SSL Handshake Protocol Specification</h3>
<dl><dd>

<h4>2.1 SSL Handshake Protocol Flow</h4>
<dl><dd>

The SSL Handshake Protocol has two major phases. The first phase is
used to establish private communications. The second phase is used for
client authentication. <p>

</p><h4>Phase 1</h4>

The first phase is the initial connection phase where both parties
communicate their "hello" messages. The client initiates the
conversation by sending the <tt>CLIENT-HELLO</tt> message. The server
receives the <tt>CLIENT-HELLO</tt> message and processes it responding
with the <tt>SERVER-HELLO</tt> message. <p>

At this point both the client and server have enough information to
know whether or not a new master key is needed.  When a new master
key is not needed, both the client and the server proceed immediately
to phase 2. </p><p>

When a new master key is needed, the <tt>SERVER-HELLO</tt> message
will contain enough information for the client to generate it.  This
includes the server's signed certificate (more about that later), a
list of bulk cipher specifications (see below), and a connection-id (a
connection-id is a randomly generated value generated by the server
that is used by the client and server during a single connection).
The client generates the master key and responds with a
<tt>CLIENT-MASTER-KEY</tt> message (or an <tt>ERROR</tt> message if
the server information indicates that the client and server cannot
agree on a bulk cipher). </p><p>

It should be noted here that each SSL endpoint uses a pair of ciphers
per connection (for a total of four ciphers). At each endpoint, one
cipher is used for outgoing communications, and one is used for
incoming communications.  When the client or server generate a session
key, they actually generate two keys, the <tt>SERVER-READ-KEY</tt>
(also known as the <tt>CLIENT-WRITE-KEY</tt>) and the
<tt>SERVER-WRITE-KEY</tt> (also known as the
<tt>CLIENT-READ-KEY</tt>). The master key is used by the client and
server to generate the various session keys (more about that
later). </p><p>

Finally, the server sends a <tt>SERVER-VERIFY</tt> message to the
client after the master key has been determined. This final step
authenticates the server, because only a server which has the
appropriate public key can know the master key. </p><p>

</p><h4>Phase 2</h4>

The second phase is the authentication phase. The server has already
been authenticated by the client in the first phase, so this phase is
primarily used to authenticate the client. In a typical scenario, the
server will require something from the client and send a request. The
client will answer in the positive if it has the needed information,
or send an <tt>ERROR</tt> message if it does not. This protocol
specification does not define the semantics of an <tt>ERROR</tt>
response to a server request (e.g., an implementation can ignore the
error, close the connection, etc. and still conform to this
specification). <p>

When a party is done authenticating the other party, it sends its
<b>finished</b> message.  For the client, the <tt>CLIENT-FINISHED</tt>
message contains the encrypted form of the <tt>CONNECTION-ID</tt> for
the server to verify. If the verification fails, the server sends an
ERROR message. </p><p>

Once a party has sent its <b>finished</b> message it must continue to
listen to its peers messages until it too receives a <b>finished</b>
message. Once a party has both sent a finished message and received
its peers finished message, the SSL handshake protocol is done. At
this point the application protocol begins to operate (Note: the
application protocol continues to be layered on the SSL Record
Protocol). </p><p>

</p></dd></dl>
<h4>2.2 Typical Protocol Message Flow</h4>
<dl><dd>

The following sequences define several typical protocol message flows
for the SSL Handshake Protocol. In these examples we have two
principals in the conversation: the client and the server. We use a
notation commonly found in the literature [10]. When something is enclosed
in curly braces "{something}key" then the something has been encrypted
using "key". <p>

</p><h4>2.2.1 Assuming no session-identifier</h4>

<pre>client-hello         C -&gt; S: challenge, cipher_specs
server-hello         S -&gt; C: connection-id,server_certificate,cipher_specs
client-master-key    C -&gt; S: {master_key}server_public_key
client-finish        C -&gt; S: {connection-id}client_write_key
server-verify        S -&gt; C: {challenge}server_write_key
server-finish        S -&gt; C: {new_session_id}server_write_key
</pre>

<h4>2.2.2 Assuming a session-identifier was found by both client &amp;
server</h4>

<pre>client-hello         C -&gt; S: challenge, session_id, cipher_specs
server-hello         S -&gt; C: connection-id, session_id_hit
client-finish        C -&gt; S: {connection-id}client_write_key
server-verify        S -&gt; C: {challenge}server_write_key
server-finish        S -&gt; C: {session_id}server_write_key
</pre>

<h4>2.2.3 Assuming a session-identifier was used and client
authentication is used</h4>

<pre>client-hello         C -&gt; S: challenge, session_id, cipher_specs
server-hello         S -&gt; C: connection-id, session_id_hit
client-finish        C -&gt; S: {connection-id}client_write_key
server-verify        S -&gt; C: {challenge}server_write_key
request-certificate  S -&gt; C: {auth_type,challenge'}server_write_key
client-certificate   C -&gt; S: {cert_type,client_cert,
			      response_data}client_write_key
server-finish        S -&gt; C: {session_id}server_write_key
</pre>

In this last exchange, the <b>response_data</b> is a function of the
<b>auth_type</b>. <p>

</p></dd></dl>
<h4>2.3 Errors</h4>
<dl><dd>

Error handling in the SSL connection protocol is very simple.  When an
error is detected, the detecting party sends a message to the other
party. Errors that are not recoverable cause the client and server to
abort the secure connection. Servers and client are required to
"forget" any session-identifiers associated with a failing
connection. <p>

The SSL Handshake Protocol defines the following errors: </p><p>

</p><dl>

<dt> NO-CIPHER-ERROR

</dt><dd> This error is returned by the client to the server when it cannot
find a cipher or key size that it supports that is also supported by the
server. This error is not recoverable. <p>

</p></dd><dt> NO-CERTIFICATE-ERROR

</dt><dd> When a REQUEST-CERTIFICATE message is sent, this error may
be returned if the client has no certificate to reply with.
This error is recoverable (for client authentication only). <p>

</p></dd><dt> BAD-CERTIFICATE-ERROR

</dt><dd> This error is returned when a certificate is deemed bad by the
receiving party. Bad means that either the signature of the
certificate was bad or that the values in the certificate were
inappropriate (e.g. a name in the certificate did not match the
expected name). This error is recoverable (for client authentication
only). <p>

</p></dd><dt> UNSUPPORTED-CERTIFICATE-TYPE-ERROR

</dt><dd> This error is returned when a client/server receives a
certificate type that it can't support. This error is recoverable (for
client authentication only). <p>

</p></dd></dl>

</dd></dl>
<h4>2.4 SSL Handshake Protocol Messages</h4>
<dl><dd>

The SSL Handshake Protocol messages are encapsulated in the SSL Record
Protocol and are composed of two parts: a single byte message type
code, and some data.  The client and server exchange messages until
both ends have sent their "finished" message, indicating that they are
satisfied with the SSL Handshake Protocol conversation. While one end
may be finished, the other may not, therefore the finished end must
continue to receive SSL Handshake Protocol messages until it too
receives a "finished" message. <p>

After the pair of session keys has been determined by each party, the
message bodies are encrypted using it.  For the client, this happens
after it verifies the session-identifier or creates a new session key
and has sent it to the server.  For the server, this happens after the
session-identifier is found to be good, or the server receives the
client's session key message. </p><p>

The following notation is used for SSLHP messages:

</p><pre>    char MSG-EXAMPLE
    char FIELD1
    char FIELD2
    char THING-MSB
    char THING-LSB
    char THING-DATA[(MSB&lt;&lt;8)|LSB];
    ...
</pre>

This notation defines the data in the protocol message, including the
message type code. The order is presented top to bottom, with the top
most element being transmitted first, and the bottom most element
transferred last. <p>

For the "THING-DATA" entry, the MSB and LSB values are actually
THING-MSB and THING-LSB (respectively) and define the number of bytes
of data actually present in the message. For example, if THING-MSB
were zero and THING-LSB were 8 then the THING-DATA array would be
exactly 8 bytes long. This shorthand is used below. </p><p>

Length codes are unsigned values, and when the MSB and LSB are
combined the result is an unsigned value. Unless otherwise specified
lengths values are "length in bytes". </p><p>

</p></dd></dl>
<h4>2.5 Client Only Protocol Messages</h4>
<dl><dd>

There are several messages that are only generated by clients. These
messages are never generated by correctly functioning servers. A
client receiving such a message closes the connection to the server
and returns an error status to the application through some
unspecified mechanism. <p>

</p><h4>CLIENT-HELLO (Phase 1; Sent in the clear)</h4>

<pre>    char MSG-CLIENT-HELLO
    char CLIENT-VERSION-MSB
    char CLIENT-VERSION-LSB
    char CIPHER-SPECS-LENGTH-MSB
    char CIPHER-SPECS-LENGTH-LSB
    char SESSION-ID-LENGTH-MSB
    char SESSION-ID-LENGTH-LSB
    char CHALLENGE-LENGTH-MSB
    char CHALLENGE-LENGTH-LSB
    char CIPHER-SPECS-DATA[(MSB&lt;&lt;8)|LSB]
    char SESSION-ID-DATA[(MSB&lt;&lt;8)|LSB]
    char CHALLENGE-DATA[(MSB&lt;&lt;8)|LSB]
</pre>

When a client first connects to a server it is required to send the
<tt>CLIENT-HELLO</tt> message. The server is expecting this message
from the client as its first message. It is an error for a client to
send anything else as its first message. <p>

The client sends to the server its SSL version, its cipher specs (see
below), some challenge data, and the session-identifier data.  The
session-identifier data is only sent if the client found a
session-identifier in its cache for the server, and the
<tt>SESSION-ID-LENGTH</tt> will be non-zero. When there is no
session-identifier for the server <tt>SESSION-ID-LENGTH</tt> must be
zero. The challenge data is used to authenticate the server. After the
client and server agree on a pair of session keys, the server returns
a <tt>SERVER-VERIFY</tt> message with the encrypted form of the
<tt>CHALLENGE-DATA</tt>. </p><p>

Also note that the server will not send its <tt>SERVER-HELLO</tt>
message until it has received the <tt>CLIENT-HELLO</tt> message. This
is done so that the server can indicate the status of the client's
session-identifier back to the client in the server's first message
(i.e. to increase protocol efficiency and reduce the number of round
trips required). </p><p>

The server examines the <tt>CLIENT-HELLO</tt> message and will verify
that it can support the client version and one of the client cipher
specs. The server can optionally edit the cipher specs, removing any
entries it doesn't choose to support. The edited version will be
returned in the <tt>SERVER-HELLO</tt> message if the
session-identifier is not in the server's cache. </p><p>

The <tt>CIPHER-SPECS-LENGTH</tt> must be greater than zero and a
multiple of 3. The <tt>SESSION-ID-LENGTH</tt> must either be zero or
16.  The <tt>CHALLENGE-LENGTH</tt> must be greater than or equal to 16
and less than or equal to 32. </p><p>

This message must be the first message sent by the client to the
server. After the message is sent the client waits for a
<tt>SERVER-HELLO</tt> message. Any other message returned by the
server (other than <tt>ERROR</tt>) is disallowed. </p><p>

</p><h4>CLIENT-MASTER-KEY (Phase 1; Sent primarily in the clear)</h4>

<pre>    char MSG-CLIENT-MASTER-KEY
    char CIPHER-KIND[3]
    char CLEAR-KEY-LENGTH-MSB
    char CLEAR-KEY-LENGTH-LSB
    char ENCRYPTED-KEY-LENGTH-MSB
    char ENCRYPTED-KEY-LENGTH-LSB
    char KEY-ARG-LENGTH-MSB
    char KEY-ARG-LENGTH-LSB
    char CLEAR-KEY-DATA[MSB&lt;&lt;8|LSB]
    char ENCRYPTED-KEY-DATA[MSB&lt;&lt;8|LSB]
    char KEY-ARG-DATA[MSB&lt;&lt;8|LSB]
</pre>

The client sends this message when it has determined a master key for
the server to use. Note that when a session-identifier has been agreed
upon, this message is not sent. <p>

The <tt>CIPHER-KIND</tt> field indicates which cipher was chosen
from the server's <tt>CIPHER-SPECS</tt>. </p><p>

The <tt>CLEAR-KEY-DATA</tt> contains the clear portion of the
<tt>MASTER-KEY</tt>. The <tt>CLEAR-KEY-DATA</tt> is combined with the
<tt>SECRET-KEY-DATA</tt> (described shortly) to form the
<tt>MASTER-KEY</tt>, with the <tt>SECRET-KEY-DATA</tt> being the least
significant bytes of the final <tt>MASTER-KEY</tt>.

The <tt>ENCRYPTED-KEY-DATA</tt> contains the secret portions of the
<tt>MASTER-KEY</tt>, encrypted using the server's public key. The
encryption block is formatted using block type 2 from PKCS#1 [5]. The
data portion of the block is formatted as follows: </p><p>

</p><pre>    char SECRET-KEY-DATA[SECRET-LENGTH]
</pre>

<tt>SECRET-LENGTH</tt> is the number of bytes of each session key that
is being transmitted encrypted. The <tt>SECRET-LENGTH</tt> plus the
<tt>CLEAR-KEY-LENGTH</tt> equals the number of bytes present in the
cipher key (as defined by the <tt>CIPHER-KIND</tt>). It is an error if
the <tt>SECRET-LENGTH</tt> found after decrypting the PKCS#1 formatted
encryption block doesn't match the expected value.  It is also an
error if <tt>CLEAR-KEY-LENGTH</tt> is non-zero and the
<tt>CIPHER-KIND</tt> is not an export cipher. <p>

If the key algorithm needs an argument (for example, DES-CBC's
initialization vector) then the <tt>KEY-ARG-LENGTH</tt> fields will be
non-zero and the <tt>KEY-ARG-DATA</tt> will contain the relevant
data. For the <tt>SSL_CK_RC2_128_CBC_WITH_MD5</tt>,
<tt>SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5</tt>,
<tt>SSL_CK_IDEA_128_CBC_WITH_MD5</tt>,
<tt>SSL_CK_DES_64_CBC_WITH_MD5</tt> and
<tt>SSL_CK_DES_192_EDE3_CBC_WITH_MD5</tt> algorithms the <tt>KEY-ARG</tt>
data must be present and be exactly 8 bytes long. </p><p>

Client and server session key production is a function of the
<tt>CIPHER-CHOICE</tt>: </p><p>

</p><dl>
<dt> <b>SSL_CK_RC4_128_WITH_MD5</b>
</dt><dt> <b>SSL_CK_RC4_128_EXPORT40_WITH_MD5</b>
</dt><dt> <b>SSL_CK_RC2_128_CBC_WITH_MD5</b>
</dt><dt> <b>SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5</b>
</dt><dt> <b>SSL_CK_IDEA_128_CBC_WITH_MD5</b>

</dt><dd> 

<pre>KEY-MATERIAL-0 = MD5[ MASTER-KEY, "0", CHALLENGE, CONNECTION-ID ]
KEY-MATERIAL-1 = MD5[ MASTER-KEY, "1", CHALLENGE, CONNECTION-ID ]

CLIENT-READ-KEY = KEY-MATERIAL-0[0-15]
CLIENT-WRITE-KEY = KEY-MATERIAL-1[0-15]
</pre>

Where <tt>KEY-MATERIAL-0[0-15]</tt> means the first 16 bytes of the
<tt>KEY-MATERIAL-0</tt> data, with <tt>KEY-MATERIAL-0[0]</tt> becoming
the most significant byte of the <tt>CLIENT-READ-KEY</tt>.  <p>

Data is fed to the MD5 hash function in the order shown, from left to
right: first the <tt>MASTER-KEY</tt>, then the "0" or "1", then the
<tt>CHALLENGE</tt> and then finally the <tt>CONNECTION-ID</tt>. </p><p>

Note that the "0" means the ascii zero character (0x30), not a zero
value. "1" means the ascii 1 character (0x31). MD5 produces 128 bits
of output data which are used directly as the key to the cipher
algorithm (The most significant byte of the MD5 output becomes the
most significant byte of the key material). </p><p>

</p></dd><dt> <b>SSL_CK_DES_64_CBC_WITH_MD5</b>

</dt><dd> 

<pre>KEY-MATERIAL-0 = MD5[ MASTER-KEY, CHALLENGE, CONNECTION-ID ]

CLIENT-READ-KEY = KEY-MATERIAL-0[0-7]
CLIENT-WRITE-KEY = KEY-MATERIAL-0[8-15]
</pre>

For DES-CBC, a single 16 bytes of key material are produced using MD5.
The first 8 bytes of the MD5 digest are used as the
<tt>CLIENT-READ-KEY</tt> while the remaining 8 bytes are used as the
<tt>CLIENT-WRITE-KEY</tt>. The initialization vector is provided in
the <tt>KEY-ARG-DATA</tt>. Note that the raw key data is not parity
adjusted and that this step must be performed before the keys are
legitimate DES keys. <p>

</p></dd><dt> <b>SSL_CK_DES_192_EDE3_CBC_WITH_MD5</b>

</dt><dd> 

<pre>KEY-MATERIAL-0 = MD5[ MASTER-KEY, "0", CHALLENGE, CONNECTION-ID ]
KEY-MATERIAL-1 = MD5[ MASTER-KEY, "1", CHALLENGE, CONNECTION-ID ]
KEY-MATERIAL-2 = MD5[ MASTER-KEY, "2", CHALLENGE, CONNECTION-ID ]

CLIENT-READ-KEY-0 = KEY-MATERIAL-0[0-7]
CLIENT-READ-KEY-1 = KEY-MATERIAL-0[8-15]
CLIENT-READ-KEY-2 = KEY-MATERIAL-1[0-7]
CLIENT-WRITE-KEY-0 = KEY-MATERIAL-1[8-15] 
CLIENT-WRITE-KEY-1 = KEY-MATERIAL-2[0-7] 
CLIENT-WRITE-KEY-2 = KEY-MATERIAL-2[8-15] 
</pre>

Data is fed to the MD5 hash function in the order shown, from left to
right: first the <tt>MASTER-KEY</tt>, then the "0", "1" or "2", then
the <tt>CHALLENGE</tt> and then finally the <tt>CONNECTION-ID</tt>. <p>

Note that the "0" means the ascii zero character (0x30), not a zero
value. "1" means the ascii 1 character (0x31). "2" means the ascii 2
character (0x32). </p><p>

A total of 6 keys are produced, 3 for the read side DES-EDE3 cipher
and 3 for the write side DES-EDE3 function. The initialization vector
is provided in the <tt>KEY-ARG-DATA</tt>. The keys that are produced
are not parity adjusted. This step must be performed before proper DES
keys are usable. </p><p>

</p></dd></dl> <p>

Recall that the <tt>MASTER-KEY</tt> is given to the server in the
<tt>CLIENT-MASTER-KEY</tt> message. The <tt>CHALLENGE</tt> is given
to the server by the client in the <tt>CLIENT-HELLO</tt> message. The
<tt>CONNECTION-ID</tt> is given to the client by the server in the
<tt>SERVER-HELLO</tt> message. This makes the resulting cipher keys a
function of the original session and the current session. Note that
the master key is never directly used to encrypt data, and therefore
cannot be easily discovered. </p><p>

The <tt>CLIENT-MASTER-KEY</tt> message must be sent after the
<tt>CLIENT-HELLO</tt> message and before the <tt>CLIENT-FINISHED</tt>
message. The <tt>CLIENT-MASTER-KEY</tt> message must be sent if the
<tt>SERVER-HELLO</tt> message contains a <tt>SESSION-ID-HIT</tt> value
of 0. </p><p>

</p><h4>CLIENT-CERTIFICATE (Phase 2; Sent encrypted)</h4>

<pre>    char MSG-CLIENT-CERTIFICATE
    char CERTIFICATE-TYPE
    char CERTIFICATE-LENGTH-MSB
    char CERTIFICATE-LENGTH-LSB
    char RESPONSE-LENGTH-MSB
    char RESPONSE-LENGTH-LSB
    char CERTIFICATE-DATA[MSB&lt;&lt;8|LSB]
    char RESPONSE-DATA[MSB&lt;&lt;8|LSB]
</pre>

This message is sent by one an SSL client in response to a server
<tt>REQUEST-CERTIFICATE</tt> message. The <tt>CERTIFICATE-DATA</tt>
contains data defined by the <tt>CERTIFICATE-TYPE</tt> value. An
<tt>ERROR</tt> message is sent with error code
<tt>NO-CERTIFICATE-ERROR</tt> when this request cannot be answered
properly (e.g. the receiver of the message has no registered
certificate). <p>

<tt>CERTIFICATE-TYPE</tt> is one of: </p><p>

</p><dl>
<dt> <b>SSL_X509_CERTIFICATE</b>
</dt><dd> The <tt>CERTIFICATE-DATA</tt> contains an X.509 (1988) [3] signed
certificate. <p>
</p></dd></dl>

The <tt>RESPONSE-DATA</tt> contains the authentication response data.
This data is a function of the <tt>AUTHENTICATION-TYPE</tt> value sent
by the server. <p>

When <tt>AUTHENTICATION-TYPE</tt> is
<tt>SSL_AT_MD5_WITH_RSA_ENCRYPTION</tt> then the
<tt>RESPONSE-DATA</tt> contains a digital signature of the following
components (in the order shown): </p><p>

</p><ul type="disc">
<li>the KEY-MATERIAL-0
</li><li>the KEY-MATERIAL-1 (only if defined by the cipher kind)
</li><li>the KEY-MATERIAL-2 (only if defined by the cipher kind)
</li><li>the CERTIFICATE-CHALLENGE-DATA (from the REQUEST-CERTIFICATE message)
</li><li>the server's signed certificate (from the SERVER-HELLO message)
</li></ul> <p>

The digital signature is constructed using MD5 and then encrypted
using the clients private key, formatted according to PKCS#1's digital
signature standard [5]. The server authenticates the client by
verifying the digital signature using standard techniques. Note that
other digest functions are supported. Either a new
<tt>AUTHENTICATION-TYPE</tt> can be added, or the algorithm-id in the
digital signature can be changed. </p><p>

This message must be sent by the client only in response to a
<tt>REQUEST-CERTIFICATE</tt> message. </p><p>

</p><h4>CLIENT-FINISHED (Phase 2; Sent encrypted)</h4>

<pre>    char MSG-CLIENT-FINISHED
    char CONNECTION-ID[N-1]
</pre>

The client sends this message when it is satisfied with the server.
Note that the client must continue to listen for server messages until
it receives a <tt>SERVER-FINISHED</tt> message. The
<tt>CONNECTION-ID</tt> data is the original connection-identifier the
server sent with its <tt>SERVER-HELLO</tt> message, encrypted using
the agreed upon session key. <p>

"<tt>N</tt>" is the number of bytes in the message that was sent, so
"<tt>N-1</tt>" is the number of bytes in the message without the
message header byte. </p><p>

For version 2 of the protocol, the client must send this message after
it has received the <tt>SERVER-HELLO</tt> message. If the
<tt>SERVER-HELLO</tt> message <tt>SESSION-ID-HIT</tt> flag is non-zero
then the <tt>CLIENT-FINISHED</tt> message is sent immediately,
otherwise the <tt>CLIENT-FINISHED</tt> message is sent after the
<tt>CLIENT-MASTER-KEY</tt> message. </p><p>

</p></dd></dl>
<h4>2.6 Server Only Protocol Messages</h4>
<dl><dd>

There are several messages that are only generated by servers. The
messages are never generated by correctly functioning clients. <p>

</p><h4>SERVER-HELLO (Phase 1; Sent in the clear)</h4>

<pre>    char MSG-SERVER-HELLO
    char SESSION-ID-HIT
    char CERTIFICATE-TYPE
    char SERVER-VERSION-MSB
    char SERVER-VERSION-LSB
    char CERTIFICATE-LENGTH-MSB
    char CERTIFICATE-LENGTH-LSB
    char CIPHER-SPECS-LENGTH-MSB
    char CIPHER-SPECS-LENGTH-LSB
    char CONNECTION-ID-LENGTH-MSB
    char CONNECTION-ID-LENGTH-LSB
    char CERTIFICATE-DATA[MSB&lt;&lt;8|LSB]
    char CIPHER-SPECS-DATA[MSB&lt;&lt;8|LSB]
    char CONNECTION-ID-DATA[MSB&lt;&lt;8|LSB]
</pre>

The server sends this message after receiving the clients
<tt>CLIENT-HELLO</tt> message. The server returns the
<tt>SESSION-ID-HIT</tt> flag indicating whether or not the received
session-identifier is known by the server (i.e. in the server's
session-identifier cache). The <tt>SESSION-ID-HIT</tt> flag will be
non-zero if the client sent the server a session-identifier (in the
<tt>CLIENT-HELLO</tt> message with <tt>SESSION-ID-LENGTH</tt> != 0)
and the server found the client's session-identifier in its cache. If
the <tt>SESSION-ID-HIT</tt> flag is non-zero then the
<tt>CERTIFICATE-TYPE</tt>, <tt>CERTIFICATE-LENGTH</tt> and
<tt>CIPHER-SPECS-LENGTH</tt> fields will be zero. <p>

The <tt>CERTIFICATE-TYPE</tt> value, when non-zero, has one of the
values described above (see the information on the
<tt>CLIENT-CERTIFICATE</tt> message). </p><p>

When the <tt>SESSION-ID-HIT</tt> flag is zero, the server packages up
its certificate, its cipher specs and a connection-id to send to the
client. Using this information the client can generate a session key
and return it to the server with the <tt>CLIENT-MASTER-KEY</tt>
message. </p><p>

When the <tt>SESSION-ID-HIT</tt> flag is non-zero, both the server and
the client compute a new pair of session keys for the current session
derived from the <tt>MASTER-KEY</tt> that was exchanged when the
<tt>SESSION-ID</tt> was created. The <tt>SERVER-READ-KEY</tt> and
<tt>SERVER-WRITE-KEY</tt> are derived from the original
<tt>MASTER-KEY</tt> keys in the same manner as the <tt>CLIENT-READ-KEY</tt>
and <tt>CLIENT-WRITE-KEY</tt>:

</p><pre>SERVER-READ-KEY = CLIENT-WRITE-KEY
SERVER-WRITE-KEY = CLIENT-READ-KEY
</pre>

Note that when keys are being derived and the <tt>SESSION-ID-HIT</tt>
flag is set and the server discovers the client's session-identifier
in the servers cache, then the <tt>KEY-ARG-DATA</tt> is used from the
time when the <tt>SESSION-ID</tt> was established. This is because the
client does not send new <tt>KEY-ARG-DATA</tt> (recall that the
<tt>KEY-ARG-DATA</tt> is sent only in the <tt>CLIENT-MASTER-KEY</tt>
message). <p>

The <tt>CONNECTION-ID-DATA</tt> is a string of randomly generated
bytes used by the server and client at various points in the
protocol. The <tt>CLIENT-FINISHED</tt> message contains an encrypted
version of the <tt>CONNECTION-ID-DATA</tt>. The length of the
<tt>CONNECTION-ID</tt> must be between 16 and than 32 bytes,
inclusive. </p><p>

The <tt>CIPHER-SPECS-DATA</tt> define a cipher type and key length (in
bits) that the receiving end supports. Each
<tt>SESSION-CIPHER-SPEC</tt> is 3 bytes long and looks like this: </p><p>

</p><pre>    char CIPHER-KIND-0
    char CIPHER-KIND-1
    char CIPHER-KIND-2
</pre>

Where CIPHER-KIND is one of: <p>

</p><ul type="disc">
<li>SSL_CK_RC4_128_WITH_MD5
</li><li>SSL_CK_RC4_128_EXPORT40_WITH_MD5
</li><li>SSL_CK_RC2_128_CBC_WITH_MD5
</li><li>SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5
</li><li>SSL_CK_IDEA_128_CBC_WITH_MD5
</li><li>SSL_CK_DES_64_CBC_WITH_MD5
</li><li>SSL_CK_DES_192_EDE3_CBC_WITH_MD5
</li></ul>
<p>

This list is not exhaustive and may be changed in the future. </p><p>

The <tt>SSL_CK_RC4_128_EXPORT40_WITH_MD5</tt> cipher is an RC4 cipher
where some of the session key is sent in the clear and the rest is
sent encrypted (exactly 40 bits of it). MD5 is used as the hash
function for production of MAC's and session key's. This cipher type
is provided to support "export" versions (i.e. versions of the
protocol that can be distributed outside of the United States) of the
client or server. </p><p>

An exportable implementation of the SSL Handshake Protocol will have
secret key lengths restricted to 40 bits. For non-export
implementations key lengths can be more generous (we recommend at
least 128 bits). It is permissible for the client and server to have a
non-intersecting set of stream ciphers. This, simply put, means they
cannot communicate. </p><p>

Version 2 of the SSL Handshake Protocol defines the
<tt>SSL_CK_RC4_128_WITH_MD5</tt> to have a key length of 128 bits. The
<tt>SSL_CK_RC4_128_EXPORT40_WITH_MD5</tt> also has a key length of 128
bits. However, only 40 of the bits are secret (the other 88 bits are
sent in the clear by the client to the server). </p><p>

The <tt>SERVER-HELLO</tt> message is sent after the server receives
the <tt>CLIENT-HELLO</tt> message, and before the server sends the
<tt>SERVER-VERIFY</tt> message. </p><p>

</p><h4>SERVER-VERIFY (Phase 1; Sent encrypted)</h4>

<pre>    char MSG-SERVER-VERIFY
    char CHALLENGE-DATA[N-1]
</pre>

The server sends this message after a pair of session keys
(<tt>SERVER-READ-KEY</tt> and <tt>SERVER-WRITE-KEY</tt>) have been
agreed upon either by a session-identifier or by explicit
specification with the <tt>CLIENT-MASTER-KEY</tt> message. The
message contains an encrypted copy of the <tt>CHALLENGE-DATA</tt> sent
by the client in the <tt>CLIENT-HELLO</tt> message. <p>

"<tt>N</tt>" is the number of bytes in the message that was sent, so
"<tt>N-1</tt>" is the number of bytes in the <tt>CHALLENGE-DATA</tt>
without the message header byte. </p><p>

This message is used to verify the server as follows. A legitimate
server will have the private key that corresponds to the public key
contained in the server certificate that was transmitted in the
<tt>SERVER-HELLO</tt> message. Accordingly, the legitimate server will
be able to extract and reconstruct the pair of session keys
(<tt>SERVER-READ-KEY</tt> and <tt>SERVER-WRITE-KEY</tt>). Finally,
only a server that has done the extraction and decryption properly can
correctly encrypt the <tt>CHALLENGE-DATA</tt>. This, in essence,
"proves" that the server has the private key that goes with the public
key in the server's certificate. </p><p>

The <tt>CHALLENGE-DATA</tt> must be the exact same length as
originally sent by the client in the <tt>CLIENT-HELLO</tt>
message. Its value must match exactly the value sent in the clear by
the client in the <tt>CLIENT-HELLO</tt> message. The client must
decrypt this message and compare the value received with the value
sent, and only if the values are identical is the server to be
"trusted". If the lengths do not match or the value doesn't match then
the connection is to be closed by the client. </p><p>

This message must be sent by the server to the client after either
detecting a session-identifier hit (and replying with a
<tt>SERVER-HELLO</tt> message with <tt>SESSION-ID-HIT</tt> not equal
to zero) or when the server receives the <tt>CLIENT-MASTER-KEY</tt>
message. This message must be sent before any Phase 2 messages or a
<tt>SEVER-FINISHED</tt> message. </p><p>

</p><h4>SERVER-FINISHED (Phase 2; Sent encrypted)</h4>

<pre>    char MSG-SERVER-FINISHED
    char SESSION-ID-DATA[N-1]
</pre>

The server sends this message when it is satisfied with the clients
security handshake and is ready to proceed with transmission/reception
of the higher level protocols data. The <tt>SESSION-ID-DATA</tt> is
used by the client and the server at this time to add entries to their
respective session-identifier caches. The session-identifier caches
must contain a copy of the <tt>MASTER-KEY</tt> sent in the
<tt>CLIENT-MASTER-KEY</tt> message as the master key is used for all
subsequent session key generation. <p>

"<tt>N</tt>" is the number of bytes in the message that was sent, so
"<tt>N-1</tt>" is the number of bytes in the <tt>SESSION-ID-DATA</tt>
without the message header byte. </p><p>

This message must be sent after the <tt>SERVER-VERIFY</tt>
message. </p><p>

</p><h4>REQUEST-CERTIFICATE (Phase 2; Sent encrypted)</h4>

<pre>    char MSG-REQUEST-CERTIFICATE
    char AUTHENTICATION-TYPE
    char CERTIFICATE-CHALLENGE-DATA[N-2]
</pre>

A server may issue this request at any time during the second phase of
the connection handshake, asking for the client's certificate.  The
client responds with a <tt>CLIENT-CERTIFICATE</tt> message immediately
if it has one, or an <tt>ERROR</tt> message (with error code
<tt>NO-CERTIFICATE-ERROR</tt>) if it doesn't. The
<tt>CERTIFICATE-CHALLENGE-DATA</tt> is a short byte string (whose
length is greater than or equal to 16 bytes and less than or equal to
32 bytes) that the client will use to respond to this message. <p>

The <tt>AUTHENTICATION-TYPE</tt> value is used to choose a particular
means of authenticating the client. The following types are defined:
</p><p>

</p><ul type="disc">
<li>SSL_AT_MD5_WITH_RSA_ENCRYPTION
</li></ul>
<p>

The <tt>SSL_AT_MD5_WITH_RSA_ENCRYPTION</tt> type requires that the
client construct an MD5 message digest using information as described
above in the section on the CLIENT-CERTIFICATE message. Once the
digest is created, the client encrypts it using its private key
(formatted according to the digital signature standard defined in
PKCS#1). The server authenticates the client when it receives the
<tt>CLIENT-CERTIFICATE</tt> message. </p><p>

This message may be sent after a <tt>SERVER-VERIFY</tt> message and
before a <tt>SERVER-FINISHED</tt> message. </p><p>

</p></dd></dl>
<h4>2.7 Client/Server Protocol Messages</h4>
<dl><dd>

These messages are generated by both the client and the server. <p>

</p><h4>ERROR (Sent clear or encrypted)</h4>

<pre>    char MSG-ERROR
    char ERROR-CODE-MSB
    char ERROR-CODE-LSB
</pre>

This message is sent when an error is detected. After the message
is sent, the sending party shuts the connection down. The receiving
party records the error and then shuts its connection down. <p>

This message is sent in the clear if an error occurs during session
key negotiation. After a session key has been agreed upon, errors are
sent encrypted like all other messages. </p><p>

</p></dd></dl>
</dd></dl>

<hr>

<h3>Appendix A: ASN.1 Syntax For Certificates</h3>
<dl><dd>

Certificates are used by SSL to authenticate servers and clients.  SSL
Certificates are based largely on the X.509 [3] certificates. An X.509
certificate contains the following information (in ASN.1 [1] notation): <p>

</p><pre>X.509-Certificate ::= SEQUENCE {
    certificateInfo CertificateInfo,
    signatureAlgorithm AlgorithmIdentifier,
    signature BIT STRING
}

CertificateInfo ::= SEQUENCE {
    version [0] Version DEFAULT v1988,
    serialNumber CertificateSerialNumber,
    signature AlgorithmIdentifier,
    issuer Name,
    validity Validity,
    subject Name,
    subjectPublicKeyInfo SubjectPublicKeyInfo
}

Version ::= INTEGER { v1988(0) }

CertificateSerialNumber ::= INTEGER

Validity ::= SEQUENCE {
    notBefore UTCTime,
    notAfter UTCTime
}

SubjectPublicKeyInfo ::= SEQUENCE {
    algorithm AlgorithmIdentifier,
    subjectPublicKey BIT STRING
}

AlgorithmIdentifier ::= SEQUENCE {
    algorithm OBJECT IDENTIFIER,
    parameters ANY DEFINED BY ALGORITHM OPTIONAL
}
</pre>

For SSL's purposes we restrict the values of some of the X.509 fields: <p>

</p><ul type="disc">

<li>The <tt>X.509-Certificate::signatureAlgorithm</tt> and
<tt>CertificateInfo::signature</tt> fields must be identical in
value. <p>

</p></li><li>The issuer name must resolve to a name that is deemed acceptable
by the application using SSL. How the application using SSL does this
is outside the scope of this memo. <p>

</p></li></ul>
<a name="#cert-check"></a>
Certificates are validated using a few straightforward steps. First,
the signature on the certificate is checked and if invalid, the
certificate is invalid (either a transmission error or an attempted
forgery occurred). Next, the <tt>CertificateInfo::issuer</tt> field is
verified to be an issuer that the application trusts (using an
unspecified mechanism). The <tt>CertificateInfo::validity</tt> field
is checked against the current date and verified.  <p>

Finally, the <tt>CertificateInfo::subject</tt> field is checked. This
check is optional and depends on the level of trust required by the
application using SSL. </p><p>

</p></dd></dl>
<h3>Appendix B: Attribute Types and Object Identifiers</h3>
<dl><dd>

SSL uses a subset of the X.520 selected attribute types as well as a
few specific object identifiers. Future revisions of the SSL protocol
may include support for more attribute types and more object
identifiers. <p>

</p><h4>B.1 Selected attribute types</h4>

<dl>

<dt> commonName { attributeType 3 }
</dt><dd> The common name contained in the distinguished name contained
within a certificate issuer or certificate subject. <p>

</p></dd><dt> countryName { attributeType 6 }
</dt><dd> The country name contained in the distinguished name contained
within a certificate issuer or certificate subject. <p>

</p></dd><dt> localityName { attributeType 7 }
</dt><dd> The locality name contained in the distinguished name contained
within a certificate issuer or certificate subject. <p>

</p></dd><dt> stateOrProvinceName { attributeType 8 }
</dt><dd> The state or province name contained in the distinguished name
contained within a certificate issuer or certificate subject. <p>

</p></dd><dt> organizationName { attributeType 10 }
</dt><dd> The organization name contained in the distinguished name
contained within a certificate issuer or certificate subject. <p>

</p></dd><dt> organizationalUnitName { attributeType 11 }
</dt><dd> The organizational unit name contained in the distinguished name
contained within a certificate issuer or certificate subject. <p>

</p></dd></dl>

<h4>B.2 Object identifiers</h4>

<dl>

<dt> md2withRSAEncryption { ... pkcs(1) 1 2 }
</dt><dd> The object identifier for digital signatures that use both MD2 and
RSA encryption. Used by SSL for certificate signature verification. <p>

</p></dd><dt> md5withRSAEncryption { ... pkcs(1) 1 4 }
</dt><dd> The object identifier for digital signatures that use both MD5 and
RSA encryption. Used by SSL for certificate signature verification. <p>

</p></dd><dt> rc4 { ... rsadsi(113549) 3 4 }
</dt><dd> The RC4 symmetric stream cipher algorithm used by SSL for bulk
encryption. <p>

</p></dd></dl>

</dd></dl>
<h3>Appendix C: Protocol Constant Values</h3>
<dl><dd>

This section describes various protocol constants. A special value
needs mentioning - the IANA reserved port number for <b>"https"</b>
(HTTP using SSL). IANA has reserved port number 443 (decimal) for
"https". <p>

</p><h4>C.1 Protocol Version Codes</h4>

<dl><dd><pre>#define SSL_CLIENT_VERSION			0x0002
#define SSL_SERVER_VERSION			0x0002
</pre></dd></dl>

<h4>C.2 Protocol Message Codes</h4>

The following values define the message codes that are used by version
2 of the SSL Handshake Protocol.  <p>

</p><dl><dd><pre>#define SSL_MT_ERROR				0
#define SSL_MT_CLIENT_HELLO			1
#define SSL_MT_CLIENT_MASTER_KEY		2
#define SSL_MT_CLIENT_FINISHED			3
#define SSL_MT_SERVER_HELLO			4
#define SSL_MT_SERVER_VERIFY			5
#define SSL_MT_SERVER_FINISHED			6
#define SSL_MT_REQUEST_CERTIFICATE		7
#define SSL_MT_CLIENT_CERTIFICATE		8
</pre></dd></dl>

<h4>C.3 Error Message Codes</h4>

The following values define the error codes used by the <tt>ERROR</tt>
message. <p>

</p><dl><dd><pre>#define SSL_PE_NO_CIPHER			0x0001
#define SSL_PE_NO_CERTIFICATE			0x0002
#define SSL_PE_BAD_CERTIFICATE			0x0004
#define SSL_PE_UNSUPPORTED_CERTIFICATE_TYPE	0x0006
</pre></dd></dl>

<h4>C.4 Cipher Kind Values</h4>

The following values define the <tt>CIPHER-KIND</tt> codes used in the
<tt>CLIENT-HELLO</tt> and <tt>SERVER-HELLO</tt> messages. <p>

</p><dl><dd><pre>#define SSL_CK_RC4_128_WITH_MD5			0x01,0x00,0x80
#define SSL_CK_RC4_128_EXPORT40_WITH_MD5	0x02,0x00,0x80
#define SSL_CK_RC2_128_CBC_WITH_MD5		0x03,0x00,0x80
#define SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5	0x04,0x00,0x80
#define SSL_CK_IDEA_128_CBC_WITH_MD5		0x05,0x00,0x80
#define SSL_CK_DES_64_CBC_WITH_MD5		0x06,0x00,0x40
#define SSL_CK_DES_192_EDE3_CBC_WITH_MD5	0x07,0x00,0xC0
</pre></dd></dl>

<h4>C.5 Certificate Type Codes</h4>

The following values define the certificate type codes used in the
<tt>SERVER-HELLO</tt> and <tt>CLIENT-CERTIFICATE</tt> messages. <p>

</p><dl><dd><pre>#define SSL_CT_X509_CERTIFICATE			0x01
</pre></dd></dl>

<h4>C.6 Authentication Type Codes</h4>

The following values define the authentication type codes used in
the <tt>REQUEST-CERTIFICATE</tt> message. <p>

</p><dl><dd><pre>#define SSL_AT_MD5_WITH_RSA_ENCRYPTION		0x01
</pre></dd></dl>

<h4>C.7 Upper/Lower Bounds</h4>

The following values define upper/lower bounds for various protocol
parameters. <p>

</p><dl><dd><pre>#define SSL_MAX_MASTER_KEY_LENGTH_IN_BITS	256
#define SSL_MAX_SESSION_ID_LENGTH_IN_BYTES	16
#define SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES	64
#define SSL_MAX_RECORD_LENGTH_2_BYTE_HEADER	32767
#define SSL_MAX_RECORD_LENGTH_3_BYTE_HEADER	16383
</pre></dd></dl>

<h4>C.8 Recommendations</h4>

Because protocols have to be implemented to be of value, we recommend
the following values for various operational parameters. This is only
a recommendation, and not a strict requirement for conformance to the
protocol. <p>

</p><dl>

<dt> Session-identifier Cache Timeout <p>

</p></dt><dd> Session-identifiers are kept in SSL clients and SSL
servers. Session-identifiers should have a lifetime that serves their
purpose (namely, reducing the number of expensive public key
operations for a single client/server pairing). Consequently, we
recommend a maximum session-identifier cache timeout value of 100
seconds. Given a server that can perform N private key operations per
second, this reduces the server load for a particular client by a
factor of 100. <p>

</p></dd></dl>

</dd></dl>
<h3>Appendix D: Attacks</h3>
<dl><dd>

In this section we attempt to describe various attacks that might
be used against the SSL protocol. This list is not guaranteed to
be exhaustive. SSL was defined to thwart these attacks. <p>

</p><h4>D.1 Cracking Ciphers</h4>

SSL depends on several cryptographic technologies. RSA Public Key
encryption [5] is used for the exchange of the session key and
client/server authentication. Various cryptographic algorithms are
used for the session cipher. If successful cryptographic attacks are
made against these technologies then SSL is no longer secure. <p>

Attacks against a specific communications session can be made by
recording the session, and then spending some large number of compute
cycles to crack either the session key or the RSA public key until the
communication can be seen in the clear. This approach is easier than
cracking the cryptographic technologies for all possible messages.
Note that SSL tries to make the cost of such of an attack greater than
the benefits gained from a successful attack, thus making it a waste
of money/time to perform such an attack. </p><p>

There have been many books [9] and papers [10] written on
cryptography.  This document does not attempt to reference them
all. </p><p>

</p><h4>D.2 Clear Text Attack</h4>

A clear text attack is done when the attacker has an idea of what kind
of message is being sent using encryption. The attacker can generate a
data base whose keys are the encrypted value of the known text (or
clear text), and whose values are the session cipher key (we call this
a "dictionary"). Once this data base is constructed, a simple lookup
function identifies the session key that goes with a particular
encrypted value. Once the session key is known, the entire message
stream can be decrypted. Custom hardware can be used to make this cost
effective and very fast. <p>

Because of the very nature of SSL clear text attacks are possible. For
example, the most common byte string sent by an HTTP client
application to an HTTP server is "GET". SSL attempts to address this
attack by using large session cipher keys. First, the client generates
a key which is larger than allowed by export, and sends some of it in
the clear to the server (this is allowed by United States government
export rules). The clear portion of the key concatenated with the
secret portion make a key which is very large (for RC4, exactly 128
bits). </p><p>

The way that this "defeats" a clear text attack is by making the
amount of custom hardware needed prohibitively large. Every bit added
to the length of the session cipher key increases the dictionary size
by a factor of 2. By using a 128 bit session cipher key length the
size of the dictionary required is beyond the ability of anyone to
fabricate (it would require more atoms to construct than exist in the
entire universe). Even if a smaller dictionary is to be used, it must
first be generated using the clear key bits. This is a time
consumptive process and also eliminates many possible custom hardware
architectures (e.g. static prom arrays). </p><p>

The second way that SSL attacks this problem is by using large key
lengths when permissible (e.g. in the non-export version). Large key
sizes require larger dictionaries (just one more bit of key size
doubles the size of the dictionary). SSL attempts to use keys that are
128 bits in length. </p><p>

Note that the consequence of the SSL defense is that a brute force
attack becomes the cheapest way to attack the key. Brute force attacks
have well known space/time tradeoffs and so it becomes possible to
define a cost of the attack. For the 128 bit secret key, the known
cost is essentially infinite. For the 40 bit secret key, the cost is
much smaller, but still outside the range of the "random hacker". </p><p>

</p><h4>D.3 Replay</h4>

The replay attack is simple. A bad-guy records a communication session
between a client and server. Later, it reconnects to the server, and
plays back the previously recorded client messages. <p>

SSL defeats this attack using a "nonce" (the connection-id) which is
"unique" to the connection. In theory the bad-guy cannot predict the
nonce in advance as it is based on a set of random events outside the
bad-guys control, and therefore the bad-guy cannot respond properly to
server requests. </p><p>

A bad-guy with large resources can record many sessions between a
client and a server, and attempt to choose the right session based on
the nonce the server sends initially in its SERVER-HELLO message.
However, SSL nonces are at least 128 bits long, so a bad-guy would
need to record approximately 2^64 nonces to even have a 50% chance of
choosing the right session. This number is sufficiently large that one
cannot economically construct a device to record 2^64 messages, and
therefore the odds are overwhelmingly against the replay attack ever
being successful. </p><p>

</p><h4>D.4 The Man In The Middle</h4>

The man in the middle attack works by having three people in
a communications session: the client, the server, and the bad guy.
The bad guy sits between the client and the server on the network
and intercepts traffic that the client sends to the server, and
traffic that the server sends to the client. <p>

The man in the middle operates by pretending to be the real server to
the client. With SSL this attack is impossible because of the usage of
server certificates. During the security connection handshake the
server is required to provide a certificate that is signed by a
certificate authority. Contained in the certificate is the server's
public key as well as its name and the name of the certificate
issuer. The client verifies the certificate by first checking the
signature and then verifying that the name of the issuer is somebody
that the client trusts.  </p><p>

In addition, the server must encrypt something with the private key
that goes with the public key mentioned in the certificate. This in
essence is a single pass "challenge response" mechanism. Only a server
that has both the certificate and the private key can respond properly
to the challenge. </p><p>

If the man in the middle provides a phony certificate, then the
signature check will fail. If the certificate provided by the bad guy
is legitimate, but for the bad guy instead of for the real server,
then the signature will pass but the name check will fail (note that
the man in the middle cannot forge certificates without discovering a
certificate authority's private key). </p><p>

Finally, if the bad guy provides the real server's certificate then
the signature check will pass and the name check will pass. However,
because the bad guy does not have the real server's private key, the
bad guy cannot properly encode the response to the challenge code, and
this check will fail. </p><p>

In the unlikely case that a bad guy happens to guess the response code
to the challenge, the bad guy still cannot decrypt the session key and
therefore cannot examine the encrypted data. </p><p>

</p></dd></dl>
<h3>Appendix E: Terms</h3>
<dl><dd>

<dl>

<dt> <b>Application Protocol</b>

</dt><dd> An application protocol is a protocol that normally layers directly
on top of TCP/IP. For example: HTTP, TELNET, FTP, and SMTP. <p>

</p></dd><dt> <b>Authentication</b>

</dt><dd> Authentication is the ability of one entity to determine the
identity of another entity. Identity is defined by this document to
mean the binding between a <i>public key</i> and a name and the
implicit ownership of the corresponding <i>private key</i>. <p>

</p></dd><dt> <b>Bulk Cipher</b>

</dt><dd> This term is used to describe a cryptographic technique with
certain performance properties. Bulk ciphers are used when large
quantities of data are to be encrypted/decrypted in a timely
manner. Examples include RC2, RC4, and IDEA. <p>

</p></dd><dt> <b>Client</b>

</dt><dd> In this document <b>client</b> refers to the application entity
that is initiates a connection to a server. <p>

</p></dd><dt> <b>CLIENT-READ-KEY</b>

</dt><dd> The session key that the client uses to initialize the client
read cipher. This key has the same value as the SERVER-WRITE-KEY. <p>

</p></dd><dt> <b>CLIENT-WRITE-KEY</b>

</dt><dd> The session key that the client uses to initialize the client
write cipher. This key has the same value as the SERVER-READ-KEY. <p>

</p></dd><dt> <b>MASTER-KEY</b>

</dt><dd> The master key that the client and server use for all session
key generation. The CLIENT-READ-KEY, CLIENT-WRITE-KEY, SERVER-READ-KEY
and SERVER-WRITE-KEY are generated from the MASTER-KEY. <p>

</p></dd><dt> <b>MD2</b>

</dt><dd> MD2 [8] is a hashing function that converts an arbitrarily long
data stream into a <b>digest</b> of fixed size. This function predates
MD5 [7] which is viewed as a more robust hash function [9]. <p>

</p></dd><dt> <b>MD5</b>

</dt><dd> MD5 [7] is a hashing function that converts an arbitrarily long
data stream into a <b>digest</b> of fixed size. The function has
certain properties that make it useful for security, the most
important of which is it's inability to be reversed. <p>

</p></dd><dt> <b>Nonce</b>

</dt><dd> A randomly generated value used to defeat "playback" attacks.
One party randomly generates a nonce and sends it to the other party.
The receiver encrypts it using the agreed upon secret key and returns
it to the sender. Because the nonce was randomly generated by the
sender this defeats playback attacks because the replayer can't know
in advance the nonce the sender will generate. The receiver denies
connections that do not have the correctly encrypted nonce. <p>

</p></dd><dt> <b>Non-repudiable Information Exchange</b>

</dt><dd> When two entities exchange information it is sometimes valuable
to have a record of the communication that is non-repudiable. Neither
party can then deny that the information exchange occurred. Version 2
of the SSL protocol does not support Non-repudiable information
exchange. <p>

</p></dd><dt> <b>Public Key Encryption</b>

</dt><dd> Public key encryption is a technique that leverages asymmetric
ciphers. A public key system consists of two keys: a public key and a
private key. Messages encrypted with the public key can only be
decrypted with the associated private key. Conversely, messages
encrypted with the private key can only be decrypted with the public
key. Public key encryption tends to be extremely compute intensive and
so is not suitable as a bulk cipher. <p>

</p></dd><dt> <b>Privacy</b>

</dt><dd> Privacy is the ability of two entities to communicate without
fear of eavesdropping. Privacy is often implemented by
<i>encrypting</i> the communications stream between the two
entities. <p>

</p></dd><dt> <b>RC2, RC4</b>

</dt><dd> Proprietary bulk ciphers invented by RSA (There is no good
reference to these as they are unpublished works; however, see
[9]). RC2 is block cipher and RC4 is a stream cipher. <p>

</p></dd><dt> <b>Server</b>

</dt><dd> The server is the application entity that responds to requests
for connections from clients. The server is passive, waiting for
requests from clients. <p>

</p></dd><dt> <b>Session cipher</b>

</dt><dd> A session cipher is a "bulk" cipher that is capable of encrypting
or decrypting arbitrarily large amounts of data.  Session ciphers are
used primarily for performance reasons. The session ciphers used by
this protocol are symmetric. Symmetric ciphers have the property of
using a single key for encryption and decryption. <p>

</p></dd><dt> <b>Session identifier</b>

</dt><dd> A session identifier is a random value generated by a client that
identifies itself to a particular server. The session identifier can
be thought of as a handle that both parties use to access a recorded
secret key (in our case a session key). If both parties remember the
session identifier then the implication is that the secret key is
already known and need not be negotiated. <p>

</p></dd><dt> <b>Session key</b>

</dt><dd> The key to the session cipher. In SSL there are four keys that
are called session keys: CLIENT-READ-KEY, CLIENT-WRITE-KEY,
SERVER-READ-KEY, and SERVER-WRITE-KEY. <p>

</p></dd><dt> <b>SERVER-READ-KEY</b>

</dt><dd> The session key that the server uses to initialize the server read
cipher. This key has the same value as the CLIENT-WRITE-KEY. <p>

</p></dd><dt> <b>SERVER-WRITE-KEY</b>

</dt><dd> The session key that the server uses to initialize the server
write cipher. This key has the same value as the CLIENT-READ-KEY. <p>

</p></dd><dt> <b>Symmetric Cipher</b>

</dt><dd> A symmetric cipher has the property that the same key can be used
for decryption and encryption. An asymmetric cipher does not have this
behavior. Some examples of symmetric ciphers: IDEA, RC2,
RC4. <p>

</p></dd></dl>

</dd></dl>
<h3>References</h3>
<dl><dd>

[1] CCITT. Recommendation X.208: "Specification of Abstract Syntax
Notation One (ASN.1). 1988. <p>

[2] CCITT. Recommendation X.209: "Specification of Basic Encoding
Rules for Abstract Syntax Notation One (ASN.1). 1988. </p><p>

[3] CCITT. Recommendation X.509: "The Directory - Authentication
Framework". 1988. </p><p>

[4] CCITT. Recommendation X.520: "The Directory - Selected Attribute
Types". 1988.</p><p>

[5] RSA Laboratories. PKCS #1: RSA Encryption Standard, Version 1.5,
November 1993. </p><p>

[6] RSA Laboratories. PKCS #6: Extended-Certificate Syntax Standard,
Version 1.5, November 1993. </p><p>

[7] R. Rivest. RFC 1321: The MD5 Message Digest Algorithm. April 1992. </p><p>

[8] R. Rivest. RFC 1319: The MD2 Message Digest Algorithm. April 1992. </p><p>

[9] B. Schneier. Applied Cryptography: Protocols, Algorithms, and
Source Code in C, Published by John Wiley &amp; Sons, Inc. 1994. </p><p>

[10] M. Abadi and R. Needham. Prudent engineering practice for
cryptographic protocols. 1994. </p><p>

</p></dd></dl>

<h3>Patent Statement</h3>

<dl><dd>

This version of the SSL protocol relies on the use of patented public
key encryption technology for authentication and encryption. The
Internet Standards Process as defined in RFC 1310 requires a written
statement from the Patent holder that a license will be made available
to applicants under reasonable terms and conditions prior to approving
a specification as a Proposed, Draft or Internet Standard. <p>

The Massachusetts Institute of Technology and the Board of Trustees of
the Leland Stanford Junior University have granted Public Key Partners
(PKP) exclusive sub-licensing rights to the following patents issued
in the United States, and all of their corresponding foreign patents: </p><p>

</p><dl><dd><pre>Cryptographic Apparatus and Method
("Diffie-Hellman")............................... No. 4,200,770 <p>

Public Key Cryptographic Apparatus
and Method ("Hellman-Merkle").................... No. 4,218,582 </p><p>

Cryptographic Communications System and
Method ("RSA")................................... No. 4,405,829 </p><p>

Exponential Cryptographic Apparatus
and Method ("Hellman-Pohlig").................... No. 4,424,414 </p><p>

</p></pre></dd></dl>

These patents are stated by PKP to cover all known methods of
practicing the art of Public Key encryption, including the variations
collectively known as El Gamal. <p>

Public Key Partners has provided written assurance to the Internet
Society that parties will be able to obtain, under reasonable,
nondiscriminatory terms, the right to use the technology covered by
these patents.  This assurance is documented in RFC 1170 titled
"Public Key Standards and Licenses".  A copy of the written assurance
dated April 20, 1990, may be obtained from the Internet Assigned
Number Authority (IANA). </p><p>

The Internet Society, Internet Architecture Board, Internet
Engineering Steering Group and the Corporation for National Research
Initiatives take no position on the validity or scope of the patents
and patent applications, nor on the appropriateness of the terms of
the assurance.  The Internet Society and other groups mentioned above
have not made any determination as to any other intellectual property
rights which may apply to the practice of this standard. Any further
consideration of these matters is the user's own responsibility. </p><p>

</p></dd></dl>

<h3>Security Considerations</h3>

<dl><dd>This entire document is about security. <p></p></dd></dl>

<h3>Author's Address</h3>

<dl><dd>

<address>
Kipp E.B. Hickman<br>
AOL/Netscape Communications Corp.<br>
466 Ellis Street <br>
Mountain View, CA 94043-4042<br>
kipp@netscape.com<br>
</address>

</dd></dl>

</div></div><!-- end #main-content and #main -->
</div><!-- end #outer-wrapper -->

</body></html>
