(* - Possible value of the "type"
   - Constructor of the new sub-type
   - Module of the type inside the new type
   - Type inside the new type
*)

let handshake_content_c = [
  "HT_HelloRequest", "HelloRequest", Some "TlsHandshake", "hello_request";
  "HT_ClientHello", "ClientHello", Some "TlsHandshake", "client_hello";
  "HT_ServerHello", "ServerHello", Some "TlsHandshake", "server_hello";
  "HT_NewSessionTicket", "NewSessionTicket", Some "TlsHandshake", "new_session_ticket";
  "HT_Certicicate", "Certificate", Some "TlsHandshake", "certificates";
  "HT_ServerHelloDone", "ServerHelloDone", Some "TlsHandshake", "server_hello_done";
]



(* - Name of the new type
   - Module to find the value of the discriminating field
   - Choices
   - Name of the "unparsed" constructor

  TODO: Why not have a parameter to tell
   - whether the choice should always be enriched
   - the name of the Unparsed constructor
 *)

let choices = [
  "handshake_content", Some "TlsEnums", handshake_content_c, "Unparsed_HSContent"
]

