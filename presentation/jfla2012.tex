\documentclass{article}
\usepackage[latin1]{inputenc}
\usepackage[french]{babel}
\usepackage{array}
\usepackage{listings}
\lstset{language=Caml, basicstyle=\footnotesize,
  morekeywords={enum, alias, struct, union,
                asn1_struct, asn1_alias,
                UnknownVal, with_lwt, Exception}}
\usepackage{xspace}
 
\usepackage{xcolor}
\newcommand{\TODO}[1]{\textcolor{red}{#1}}

\newcommand{\FAceSL}{\TODO{FAceSL}\xspace}
\newcommand{\FAceSLTypes}{\TODO{FAceSLTypes}\xspace}
\newcommand{\FAceSLType}{\TODO{FAceSLType}\xspace}

\title{Utilisation de \texttt{camlp4} pour l'écriture rapide de \emph{parsers}}
\author{Olivier Levillain}

\begin{document}

\maketitle

Dans le cadre de ses activités d'expertise, le laboratoire sécurité
des réseaux et protocoles (LRP) de l'agence nationale de la sécurité
des systèmes d'information (ANSSI) est amené à étudier divers
protocoles de communication. L'étude fine de ces protocoles passe par
l'utilisation de \emph{parsers} (dissecteurs) de confiance permettant
d'analyser les messages échangés lors d'une instance du protocole.

L'expérience a montré qu'il était souvent utile (voire nécessaire) de
disposer d'implémentations indépendantes et robustes pour étudier et
comprendre les comportements d'un protocole donné, en particulier pour
détecter et caractériser les messages incorrects. En effet, les
implémentations disponibles de clients, serveurs ou dissecteurs sont
parfois limitées (refus de certaines options), laxistes (accetation
silencieuse de paramètres erronés) ou fragile (terminaison brutale du
programme pour des valeurs inattendues, qu'elles soient licites ou
non).

Ce constat a donc conduit au développement de certains outils par les
membres du laboratoire. L'objectif était de développer
\emph{rapidement} des dissecteurs \emph{robustes} et
\emph{efficaces}. Pour cela, plusieurs langages de programmation ont
été testés (C++, python, OCaml). L'objet de ce document est de
présenter l'une de ces implémentations, reposant sur le pré-processeur
\texttt{camlp4} d'OCaml.



\section{Contexte}

Le point de départ de ces travaux était l'analyse d'une quantité
importante de données récoltées concernant le protocole TLS. Ces
données proviennent de résultats mis à dispositions par l'Electronic
Frontier Foundation (EFF) et de collectes effectuées par Télécom
SudParis et l'ANSSI. Les traces analysées contiennent une très grande
diversité de réponses, et certaines sont incohérentes ou non conformes
au protocole TLS.

Face à cet imposant corpus, il était difficile d'utiliser des outils
existants pour extraire de manière fiable l'information pertinente
pour les analyses. Dans le cas de TLS, l'objectif était d'effectuer un
état des lieux de la qualité des serveurs TLS dans le monde, et son
évolution dans le temps. Ces travaux ont fait l'objet d'une
publication à venir à ACSAC~\cite{ACSAC2012}.

Le premier \emph{parser} réalisé pour cette tâche a été écrit en
Python, permettant d'obtenir rapidement un prototype pour extraire les
premiers éléments des données. Cependant, ce premier programme s'est
révélé trop lent face au volume de données à traiter. Une seconde
implémentation a donc vu le jour, en C++. Celle-ci reposait sur les
\emph{templates} et la programmation objet, et permettait d'obtenir un
dissecteur flexible et efficace, mais au prix d'une grande quantité de
code à écrire et d'erreurs de programmation pas toujours évidentes à
diagnostiquer (fuites mémoire, erreurs de segmentation).

Pour pallier ce manque de robustesse, une troisième version des outils
a été entreprise, en OCaml. Afin de conserver la flexibilité imaginée
pour le second prototype, un langage spécifique a été développé pour
décrire les structures à disséquer. Les outils résultants étaient
expressifs, efficaces et plus fiables que la version
précédente. Pourtant, l'extensibilité de cette implémentation
nécessitait encore une lourdeur dans l'écriture du code qui s'est
révélée assez fastidieuse à l'usage.

Finalement, une nouvelle implémentation en OCaml a été réalisée pour
tenter de réunir l'ensemble des qualités recherchées pour le
développement de \emph{parsers}:
\begin{itemize}
\item rapidité d'écriture;
\item garanties fortes sur le fonctionnement des outils;
\item efficacité des programmes produits.
\end{itemize}
Cette quatrième mouture, \FAceSL, résulte de la fusion entre le
langage spécifique de description des objets analysés et le langage de
programmation. Pour cela, le processeur \texttt{camlp4} a été employé
pour la génération automatique des types et des fonctions à partir de
descriptions brèves des structures à disséquer.



\section{Présentation de \FAceSL}


\subsection{Un premier exempe: le format TAR}

L'en-tête du format TAR est décrit dans le
tableau~\ref{tab:tar-format}, et décrit deux versions du format: le
format original (colonne TAR) et une variante plus récente (colonne
\texttt{ustar}). Pour des raisons de compatibilité, les valeurs
numériques sont systématiquement stockées sous la forme d'une chaîne
de caractère représentant la valeur numérique en octal\footnote{Cette
  méthode permet d'éviter de tomber dans les pièges de
  l'\emph{endianness} par exemple, mais au prix d'une plus grande
  consommation mémoire.}. L'en-tête est contenu dans un «~bloc~» de
512~octets, et le contenu du fichier qui suit l'en-tête est complété
par des caractères nuls pour former des blocs de 512~octets.

\begin{table}
  \begin{center}
    \begin{tabular}{|r|r|l|l|}
      \hline
      \multicolumn{1}{|c|}{\bf Offset} &
      \multicolumn{1}{c|}{\bf Long.} &
      \multicolumn{2}{c|}{\bf Description} \\
      & & \multicolumn{1}{c|}{\bf TAR} &
      \multicolumn{1}{c|}{\bf \tt ustar} \\
      \hline

      \hline
        0 & 100 & \multicolumn{2}{l|}{Nom du fichier} \\
      \hline
      100 &   8 & \multicolumn{2}{l|}{Permissions} \\
      \hline
      108 &   8 & \multicolumn{2}{l|}{UID} \\
      \hline
      116 &   8 & \multicolumn{2}{l|}{GID} \\
      \hline
      124 &  12 & \multicolumn{2}{l|}{Taille du fichier} \\
      \hline
      136 &  12 & \multicolumn{2}{l|}{\emph{Timestamp} de la dernière modification} \\
      \hline
      148 &   8 & \multicolumn{2}{l|}{Somme de contrôle de l'en-tête} \\
      \hline
      156 &   1 & Indicateur de lien & Type de fichier \\
      \hline
      157 & 100 & \multicolumn{2}{l|}{Nom du fichier pointé par le lien} \\
      \hline
      257 &   6	& \multicolumn{1}{c|}{-} & Indicateur \texttt{"ustar"} \\
      \hline
      263 &   2	& \multicolumn{1}{c|}{-} & Version UStar ("00") \\
      \hline
      265 &  32 & \multicolumn{1}{c|}{-} & Propriétaire \\
      \hline
      297 &  32 & \multicolumn{1}{c|}{-} & Groupe propriétaire \\
      \hline
      329 &   8 & \multicolumn{1}{c|}{-} & Numéro majeur du périphérique \\
      \hline
      337 &   8 & \multicolumn{1}{c|}{-} & Numéro mineur du périphérique \\
      \hline
      345 & 155 & \multicolumn{1}{c|}{-} & Préfixe \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Description de l'en-tête TAR.}
  \label{tab:tar-format}
\end{table}

Le champ à l'offset~156 décrit le type de fichier, et a été étendu par
\texttt{ustar}. La table \ref{tab:tar-filetypes} récapitule les
différentes valeurs qu'il peut prendre.

\begin{table}
  \begin{center}
    \begin{tabular}{|>{\tt}c|l|c|}
      \hline
      \multicolumn{1}{|c|}{\bf Caractère} &
      \multicolumn{1}{c|}{\bf Description} &
      \multicolumn{1}{c|}{\bf \tt ustar} \\
      \hline

      \hline
      <NUL>, 0 & fichier ordinaire & - \\
      1 & lien dur & - \\
      2 & lien symbolique & - \\
      \hline
      3 & périphérique en mode caractères & oui \\
      4 & périphérique en mode blocs & oui \\
      5 & répertoire & oui \\
      6 & file FIFO & oui \\
      7 & fichier contigu & oui \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Valeurs du champ «~Indicateur de lien/Type de fichier~».
    La colonne \texttt{ustar} indique si la valeur est spécifique à
    la version étendue du format.}
  \label{tab:tar-filetypes}
\end{table}


Afin d'utiliser notre préprocesseur pour décrire les fichiers au
format TAR, commençons par décrire les valeurs du champ «~Indicateur
de lien/Type de fichier~». Il s'agit d'une énumération sur 8~bits,
dont nous connaissons certaines valeurs qui s'écrit avec le nouveau
mot-clé \texttt{enum}. Si l'analyseur généré rencontre un type
inconnu, il est possible d'utiliser un constructeur spécifique ou de
lever une exception. Nous avons choisi le premier cas, avec le
constructeur spécifique \texttt{UnknownFileType}:
\begin{lstlisting}
enum file_type (8, UnknownVal UnknownFileType, []) =
  | 0 -> NormalFile
  | 0x30 -> NormalFile
  | 0x31 -> HardLink
  | 0x32 -> SymbolicLink
  | 0x33 -> CharacterSpecial
  | 0x34 -> BlockSpecial
  | 0x35 -> Directory
  | 0x36 -> FIFO
  | 0x37 -> ContiguousFile
\end{lstlisting}

Ensuite, on peut décrire l'enregistrement contenant les différents
champs constituant d'un en-tête à l'aide du mot clé \texttt{struct},
qui ressemble à la description d'un enregistrement Caml, mais qui
accepte des types enrichis nommés \FAceSLTypes:
\begin{lstlisting}
struct tar_header = {
  file_name : string(100);
  file_mode : string(8);
  owner_uid : string(8);
  owner_gid : string(8);
  file_size : string(12);
  timestamp : string(12);
  checksum  : string(8);
  file_type : file_type;
  linked_file : string(100);
  ustar_magic : magic("ustar\x0000");
  owner_user : string(32);
  owner_group : string(32);
  device_major : string(8);
  device_minor : string(8);
  filename_prefix : string(155);
  hdr_padding : binstring(12);
}

struct tar_entry = {
  header : tar_header;
  file_content : binstring(header.file_size);
  file_padding : binstring(512 - (header.file_size % 512))
}

alias tar_file = list of tar_entry;
\end{lstlisting}

Le code resultant du préprocesseur permet alors d'ouvrir une archive
simplement à l'aide de la fonction \texttt{parse\_tar\_file}, qui
prend en entier la chaîne de caractères correspondant au contenu du
fichier. Afin de traiter des données importantes de manière efficace,
il est également possible de produire une version du \emph{parser} en
mode flux, qui repose sur la bibliothèque \texttt{lwt}. Pour cela, il
suffit de redéfinir l'alias en lui adjoignant la et d'utiliser cette
fois la fonction \texttt{lwt\_parse\_tar\_file}:
\begin{lstlisting}
alias tar_file [with_lwt] = list of tar_entry;

let handle_filename filename =
  Lwt_unix.openfile filename [Unix.O_RDONLY] 0 >>= fun fd
  lwt_parse_tar_file (input_of_fd filename fd) >>= fun tar_file
  let print_filename entry = print_string entry.file_name in
  List.iter print_filename tar_file;
  return ()

let _ =
  Lwt_unix.run (handle_filename "test.tar");
\end{lstlisting}


\subsection{Pour aller plus loin}

La première version proposée est fonctionnelle, mais si l'on souhaite
proprement prendre en compte les vieilles archives, ne contenant pas
l'en-tête étendu commençant par le marqueur \texttt{ustar}, on peut
réécrire la description de l'en-tête de la manière suivante, en
éclatant l'en-tête en deux morceaux, dont un optionnel.
\begin{lstlisting}
struct ustar_header = {
  ustar_magic : magic("ustar\x0000");
  owner_user : string(32);
  owner_group : string(32);
  device_major : string(8);
  device_minor : string(8);
  filename_prefix : string(155);
}

struct tar_header = {
  file_name : string(100);
  file_mode : string(8);
  owner_uid : string(8);
  owner_gid : string(8);
  file_size : string(12);
  timestamp : string(12);
  checksum  : string(8);
  file_type : file_type;
  linked_file : string(100);
  optional ustar_header : ustar_header;
  hdr_padding : binstring;
}

struct tar_entry = {
  header : container(512) of tar_header;
  file_content : binstring(header.file_size);
  file_padding : binstring(512 - (header.file_size % 512))
  checksum_verification : check of check_crc32 (header,
                                    file_content, file_padding);
}

alias tar_file = list of tar_entry;
\end{lstlisting}

Avec cette seconde version, on utilise un conteneur de 512 octets pour
lire l'en-tête. Si l'en-tête est étendu, le champ
\texttt{ustar\_header} sera peuplé par la fonction
\texttt{parse\_ustar\_header} et le champ \texttt{hdr\_padding}, une
chaîne binaire consommant les octets restants du conteneur,
contiendra~12~octets; dans le cas contraire, la fonction échouera, le
champ \texttt{ustar\_header} vaudra \texttt{None} et
\texttt{hdr\_padding} aura une longueur de 255~octets.

Le lecteur attentif aura également remarqué l'ajout d'un champ intitulé
\texttt{checksum\_verification}, qui permet d'exécuter une
vérification de la somme de contrôle une fois l'entrée TAR entièrement
disséquée. Cette ligne ne produit pas de champ dans le type OCaml
\texttt{tar\_entry} généré, mais appelle la fonction
\texttt{check\_crc32} (à écrire) sur les champs déjà disséqués. On
pourrait utiliser ce type de champs pour vérifier d'autres propriétés
(le champ \texttt{hdr\_padding} est par exemple censé ne contenir que
des caractères nuls).

Le format TAR faisant un usage important des chaînes de caractères
encodant une valeur numérique, on pourrait aussi créer de toute pièce
un nouveau type, \texttt{tar\_numstring}, de la manière
suivante\footnote{Pour des raisons historiques, un champ de 8~octets
  sera terminé par un espace ou un caractère nul, ne laissant ainsi en
  pratique que 7~octets pour encoder la valeur.}:
\begin{lstlisting}
type tar_numstring = int

let parse_tar_numstring len input =
  let octal_value = parse_string (len - 1) input in
  drop_bytes 1 input;
  int_of_string ("0o" ^ octal_value)

let dump_tar_numstring len v =
  Printf.printf "%*.*o\x00" len len v

let print_tar_numstring ?indent:(indent="")
                        ?name:(name="numstring") v =
  Printf.sprintf "%s%s: %d (%o)\n" indent name v v
\end{lstlisting}

On peut alors modifier les champs représentant des valeurs numériques
en octal en replaçant le type \texttt{string(n)} par
\texttt{tar\_numstring(n)}. L'expressivité de \FAceSL peut ainsi être
étendue facilement à l'aide de \FAceSLTypes personnalisés.



\section{Description des extensions du langage}


\subsection{\'Enumérations}

La première construction ajoutée par \FAceSL est l'énumération, qui
ressemble à l'\texttt{enum} du C, le typage fort en plus.

\shorthandoff{:}
\begin{tabbing}
  \textit{énumération} ::= \textbf{\tt enum} \= \textit{identifiant} (\textit{taille}, \textit{comportement}, \textit{enum\_options}) = \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [, \textit{texte}\footnote{Ce
    texte sera renvoyé par \texttt{string\_of\_enum} pour cette valeur de l'énumération.
    Si aucun texte n'est donné, le nom du constructeur sera utilisé.}] \\
  \> ... \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [, \textit{texte}] \\
  \\
  \textit{comportement} ::\= = \= \textbf{\tt UnknownVal} \textit{Constructor} \\
  \> $\vert$ \> \textbf{\tt Exception} \textit{Exception} \\
  \\
  \textit{enum\_option} \= ::= \textbf{\tt with\_lwt} \\
\end{tabbing}
\shorthandon{:}

Une déclaration d'énumération \texttt{enum} est alors transformée en
une déclaration de type OCaml et un ensemble de fonctions. Par
exemple, la déclaration suivante:
\begin{lstlisting}
enum tls_version (16, UnknownVal V_Unknown, [with_lwt]) =
  | 0x0002 -> V_SSLv2, "SSLv2"
  | 0x0300 -> V_SSLv3, "SSLv3"
  | 0x0301 -> V_TLSv1, "TLSv1.0"
  | 0x0302 -> V_TLSv1_1, "TLSv1.1"
  | 0x0303 -> V_TLSv1_2, "TLSv1.2"
\end{lstlisting}

\noindent génère le type somme suivant:
\begin{lstlisting}
type tls_version =
  | V_SSLv2 | V_SSLv3 | V_TLSv1 | V_TLSv1_1 | V_TLSv1_2
  | V_Unknown of int
\end{lstlisting}

\noindent et les fonctions suivantes:
\begin{lstlisting}
val string_of_tls_version : tls_version -> string
val int_of_tls_version : tls_version -> int
val tls_version_of_int : int -> tls_version
val tls_version_of_string : string -> tls_version

val parse_tls_version : string_input -> tls_version
val lwt_parse_tls_version : lwt_input -> tls_version
val dump_tls_version : tls_version -> string
val print_tls_version : ?indent:string -> ?name:string ->
                        tls_version -> string
\end{lstlisting}

Les quatre premières fonctions générées permettent simplement de
convertir le type énumération depuis et vers les entiers et les
chaînes de caractères. Le \textit{comportement} de la grammaire
ci-dessus indique comment \texttt{tls\_version\_of\_int} doit traiter
une valeur non fournie dans l'énumération: ici, \texttt{UnknownVal
  V\_Unknown} indique qu'il faut renvoyer une valeur
\texttt{V\_Unknown i} où \texttt{i} est la valeur non
reconnue. L'autre comportement possible est de lever une exception.

Les quatre fonctions suivantes fournissent des services de plus haut
niveau: \emph{parser} l'énumération depuis une chaîne de caractères
(\texttt{parse}) ou un flux \texttt{Lwt} (\texttt{lwt\_parse}),
exporter une structure au format binaire (\texttt{dump}) ou en obtenir
une version affichable (\texttt{print}). Cette dernière fonction
accepte des options pour modifier l'indentation et le nom de la
structure à afficher.


\subsection{\FAceSLTypes}

Avant de poursuivre avec les constructions apportées par \FAceSL, il
est nécessaire de décrire les \FAceSLTypes, les types binaires compris
par \texttt{struct} et \texttt{union}.

\shorthandoff{:}
\begin{tabbing}
  \textit{\FAceSLType} ::\= = \= \textbf{\tt char} \\
  \> $\vert$ \> \textbf{\tt uintN} \\
  \> $\vert$ \> \textbf{\tt ipv4} \\
  \> $\vert$ \> \textbf{\tt ipv6} \\
  \> $\vert$ \> \textbf{\tt string} \\
  \> $\vert$ \> \textbf{\tt string} (\textit{expression}) \\
  \> $\vert$ \> \textbf{\tt string} [\textit{type entier}] \\
  \> $\vert$ \> \textbf{\tt list} \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt list} (\textit{expression}) \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt list} [\textit{type entier}] \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt container} (\textit{expression}) \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt container} [\textit{type entier}] \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textit{custom type} \\
  \> $\vert$ \> \textit{custom type} (\textit{paramètres}) \\
\end{tabbing}
\shorthandon{:}

\FAceSL implémente les fonctions \texttt{parse}, \texttt{lwt\_parse},
\texttt{dump} et \texttt{print} pour un certain nombre de types de
base: les entiers non signés, les adresses IPv4 et IPv6 encodées en
binaire, les chaînes de caractères\footnote{En plus des types
  \texttt{string} présentés ici, qui correspondent à des chaînes de
  caractères imprimables, un type \texttt{binstring} est également
  disponible. La seule différence entre ces deux types est que la
  fonction \texttt{print} générée affichera la chaîne directement, ou
  sous sa représentation héxadécimale.}.

En plus de ces types scalaires, le type \texttt{list} permet de
décrire des listes d'objets du même type; le type \texttt{container}
sert à encapsuler un sous-type en spécifiant la taille de la
sous-chaîne à lire depuis l'entrée. Nous l'avons utilisé pour la
gestion de l'en-tête TAR qui est contenu dans un bloc de 512~octets
mais dont la partie utile peut varier (selon qu'il soit conforme au
standard \texttt{ustar} ou non).

Pour les chaînes de caractères et les listes, les \emph{parsers}
générés par défaut essaient de lire l'ensemble de la chaîne qui leur
est passée en entrée. On peut cependant préciser avec une expression
entre parenthèses la taille attendue pour une chaîne de caractères en
octets ou le nombre d'éléments attendus pour une liste. Un autre
format fréquemment rencontré pour les chaînes de caractères ou les
listes est de faire précéder la chaîne ou la liste par un champ
longueur qui définit le nombre d'octets utiles pour l'élément qui
suit; on peut spécifier à l'aide de crochets qu'un tel type est
attendu: \texttt{\textbf{list} [uint16] \textbf{of} uint16} permet de
décrire une liste d'entiers sur 16~bits dont la longueur totale en
octets est codées sur un entier 16~bits\footnote{Ce type particulier
  peut servir à décrire la liste des suites cryptographiques
  (\emph{ciphersuites}) proposées par un client dans le protocole
  TLS.}. Pour un conteneur, on utilisera les parenthèses ou les
crochets pour décrire comment trouver la taille en octet du champ
encapsulé.

Enfin, pour étendre les types binaires, il suffit de créer un nouveau
type OCaml, d'écrire les fonctions \texttt{parse}, \texttt{dump} et
\texttt{print} correspondantes\footnote{On écrira également la
  fonction \texttt{lwt\_parse} si besoin.} avant de pouvoir utiliser
ce nouveau type comme un \FAceSLType. Il est de plus possible de
spécifier des paramètres à passer aux fonctions \texttt{parse},
\texttt{lwt\_parse} et \texttt{dump} dans le cas de types
personnalisés. Il peut s'agir de structures ou d'unions, mais
également de types pour lesquels on a écrit à la main les fonctions
nécessaires, comme cela a été fait précédemment pour
\texttt{tar\_numstring}.


\subsection{Structures}

Les structures \texttt{struct} que l'on peut exprimer en \FAceSL sont
des enregistrements qui viennent avec leurs fonctions \texttt{parse},
\texttt{dump} et texttt{print} automatiquement générées.

\shorthandoff{:}
\begin{tabbing}
  \textit{structure} ::= \= \textbf{\tt struct} \= \textit{identifiant} [\textit{struct\_options}] = \{ \\
  \> \> [\textbf{\tt optional}] \textit{identifiant} : \textit{\FAceSLType}; \\
  \> \> ... \\
  \> \> [\textbf{\tt optional}] \textit{identifiant} : \textit{\FAceSLType} \\
  \> \} \\
  \\
  \textit{struct\_option} ::\= = \= \textbf{\tt with\_lwt} \\
  \> $\vert$ \> \textbf{\tt with\_exact} \\
  \> $\vert$ \> \textbf{\tt top} \\
  \> $\vert$ \> \textbf{\tt param} \textit{expression} \\
\end{tabbing}
\shorthandon{:}

Un exemple simple est donné par les messages d'alerte du protocole
TLS. À partir de deux types énumérations sur 8~bits, on peut créer
l'enregistrement simplement:
\begin{lstlisting}
enum tls_alert_level (8, UnknownVal AL_Unknown, []) =
  | 1 -> AL_Warning, "Warning"
  | 2 -> AL_Fatal, "Fatal"

enum tls_alert_type (8, UnknownVal AT_Unknown, []) =
  | 0 -> AT_CloseNotify, "CloseNotify"
  | 10 -> AT_UnexpectedMessage, "UnexpectedMessage"
    ...
  | 115 -> AT_UnknownPSKIdentity, "UnknownPSKIdentity"

struct tls_alert = {
  alert_level : tls_alert_level;
  alert_type : tls_alert_type
}
\end{lstlisting}

L'option \texttt{with\_lwt} déclenche la génération de la fonction
\texttt{lwt\_parse}. L'option \texttt{with\_exact} permet de créer une
fonction \texttt{exact\_parse} qui vérifie que la chaîne de caractères
fournie en entrée correspond exactement à l'objet disséqué et qu'il
n'existe pas d'octets à la fin de la chaîne de caractères. L'option
\texttt{top} est un raccourci pour les deux options précédentes,
puisqu'elle décrit un objet au niveau le plus haut. Enfin, il est
possible d'ajouter des paramères aux fonctions \texttt{parse} et
\texttt{dump} générées; ces paramètres pourront être utilisés dans les
expressions entre parenthèses (pour indiquer une longueur ou pour
transmettre un argument à un type personnalisé.

\subsection{Unions}

Empruntant encore la terminologie du langage C, les unions sont en
réalité des types somme augmentés par un constructeur par
défaut. L'idée est d'utiliser un discriminant passé en argument à la
fonction \texttt{parse} pour en déduire le constructeur du type somme
à utiliser. Ce discriminant va être comparé aux différents
motifs proposés dans la description de l'union.

\shorthandoff{:}
\begin{tabbing}
  \textit{union} ::= \textbf{\tt union} \= \textit{identifiant} (\textit{comportement}, \textit{union\_options}) = \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \> ... \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \\
  \textit{comportement} ::\= = \= \textit{Constructor} \\
  \> $\vert$ \> \textit{Constructor} \textbf{\tt of} \textit{\FAceSLType} \\
  \\
  \textit{struct\_option} ::\= = \= \textbf{\tt with\_lwt} \\
  \> $\vert$ \> \textbf{\tt with\_exact} \\
  \> $\vert$ \> \textbf{\tt top} \\
  \> $\vert$ \> \textbf{\tt enrich} \\
  \> $\vert$ \> \textbf{\tt exhaustive} \\
  \> $\vert$ \> \textbf{\tt param} \textit{expression} \\
\end{tabbing}
\shorthandon{:}

Si on ne souhaite pas enrichir l'union ou que le discriminant n'a pas
une valeur attendue, on utilise le constructeur par défaut, qui
récupère par défaut la chaîne de caractères restant. Cela peut être
modifié en spécifiant un \FAceSLType dans le comportement.

L'enrichissement de l'union \texttt{u} est contrôlé par une variable
globale \texttt{enrich\_u}, initialisée à \texttt{true} si l'option
\texttt{enrich} est activée, à \texttt{false} sinon. De plus, on peut
surcharger cette valeur par un argument optionnel \texttt{~enrich} de
la fonction \texttt{parse}. Si l'option \texttt{exhaustive} est
positionnée, le \emph{pattern matching} généré pour l'enrichissement
devra être exhaustif.

Les options \texttt{with\_lwt}, \texttt{with\_exact}, \texttt{top} et
\texttt{param} ont le même sens que pour les structures.

Le protocole BGP définit la notion de système autonome (AS), un numéro
identifiant un opérateur. Initialiement, les AS étaient représentés
sur 16~bits, mais cela n'est plus suffisant désormais et les AS sont
parfois décrits sur 32~bits. L'exemple suivant montre comment décrire
un AS avec une union, et comment employer le type généré dans une
structure:
\begin{lstlisting}
union autonomous_system (UnparsedAS, [enrich]) =
  | 16 -> AS16 of uint16
  | 32 -> AS32 of uint32

struct bgp_as_path_segment [param as_size] = {
  path_segment_type : uint8;
  path_segment_length : uint8;
  path_segment_value : list(path_segment_length)
                           of autonomous_system(as_size)
}
\end{lstlisting}

Le type \texttt{autonomous\_system} sera vu comme un entier~16~bits si
le discriminant qui lui est passé en argument vaut 16, ou un entier
32~bits s'il vaut 32. La déclaration de la structure
\texttt{bgp\_as\_path\_segment} conduit à la génération d'une fonction
\texttt{parse\_bgp\_as\_path\_segment} qui prend un argument
supplémentaire (\texttt{as\_size}), puis tente de lire le type de
segment (un octet), la longueur du segment (un autre octet), puis une
liste d'AS contenant \texttt{path\_segment\_length} éléments du type
union défini. On remarquera que la valeur \texttt{as\_size} est alors
passée comme discriminant à \texttt{parse\_autonomous\_system}.


\subsection{Alias}

Pour permettre de produire simplement des fonctions \texttt{parse},
\texttt{dump} et \texttt{print} pour des listes, on peut déclarer des
alias comme nous l'avons fait pour le format TAR.

\shorthandoff{:}
\begin{tabbing}
  \textit{alias} ::= \textbf{\tt alias} \textit{identifiant} = \textit{\FAceSLType} \\
\end{tabbing}
\shorthandon{:}


\subsection{Types ASN.1}

Pour décrire les structures ASN.1, il est nécessaire de disposer des
types ASN.1 de bases.

\shorthandoff{:}
\begin{tabbing}
  \textit{ASN1Type} ::\= = \= \textbf{\tt asn1\_bool} \\
  \> $\vert$ \> \textbf{\tt asn1\_integer} \\
  \> $\vert$ \> \textbf{\tt asn1\_bitstring} \\
  \> $\vert$ \> \textbf{\tt asn1\_enumerated} \\
  \> $\vert$ \> \textbf{\tt asn1\_octetstring} \\
  \> $\vert$ \> \textbf{\tt asn1\_null} \\
  \> $\vert$ \> \textbf{\tt asn1\_oid} \\
  \> $\vert$ \> \textbf{\tt asn1\_string} \\
  \> $\vert$ \> \textbf{\tt asn1\_list} \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt asn1\_container} \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{asn1\_anything} \\
  \> $\vert$ \> \textit{custom type} \\
  \> $\vert$ \> \textit{custom type} (\textit{paramètres}) \\
\end{tabbing}
\shorthandon{:}

\TODO{options for enumerated, string}

\TODO{ici on a les types des contenus}

\TODO{list (min,max) => sequence of / set of}

\TODO{description à part des en-têtes}


\subsection{Structures ASN.1}

\TODO{TODO}


\subsection{Alias ASN.1}

\TODO{TODO}


\section{Quelques mots sur l'implémentation \texttt{camlp4}}


\subsection{Des chiffres}

\TODO{Nb de lignes}

\TODO{Disponibilité du package}


\subsection{Anecdotes}

\TODO{Difficulté à écrire du camlp4 car peu de documentation, mais une
  fois les types compris, la manipulation de l'AST est extrêmement
  riche.}

\TODO{Comportement surprenant: camlp4o <preprocessors> <fichier.ml> a
  un comportement différent selon que la sortie standard est un pipe
  ou une console...}



\section{Applications}


\subsection{TLS et X.509}

Le point de départ de ces travaux sur les \emph{parsers} était
l'analyse de données TLS~\cite{rfc5246} contenant des certificats
X.509~\cite{rfc5280} (structures ASN.1 encodées au format DER). Il
s'agit donc logiquement de la première application concrète de
\FAceSL.

À ce jour, une grande partie des messages du protocole a pu être
décrite à l'aide de \FAceSL, ainsi que les certificats X.509. La
répartition du nombre de lignes de code est la suivante:
\begin{itemize}
\item énumérations TLS\footnote{L'énumération décrivant l'ensemble des
    suites cryptographiques comportent en particulier~300~valeurs.}:
  500~lignes;
\item description des messages TLS: 150~lignes;
\item description des certificats X.509 : 100~lignes;
\item outil pour tester un serveur TLS (test des versions et suites
  cryptographiques supportées, affichage de la partie en clair de
  l'échange): 250~lignes.
\end{itemize}

\TODO{Exemple de struct/union}

Ainsi, en environ 1000~lignes de code\footnote{Ce décompte ne comprend
  évidemment pas le préprocesseur ni les fonctions auxiliaires
  fournissant les services de base (\texttt{parse\_uint8} et
  \texttt{dump\_ipv4} par exemple) discutées dans la section
  précédente.}, il a été possible de décrire une grande partie du
protocole TLS ainsi qu'un outil de test.

Afin d'arriver à une implémentation complète d'une pile TLS, il
faudrait encore ajouter les éléments suivants:
\begin{itemize}
\item détailler les extensions X.509 qui ne sont que partiellement
  enrichies aujourd'hui;
\item écrire et animer l'automate du protocole de négociation TLS (à
  ce jour, seule une animation rudimentaire a été développée pour
  réaliser le programme de tests);
\item ajouter les appels aux fonctions cryptographiques pour mettre
  réellement en \oe uvre le tunnel négocié.
\end{itemize}


\TODO{Cette première ébauche a été testée avec succès pour
  ... efficacité, description des outils.}


\subsection{MRT}

BGP est l'un des protocoles étudiés dans le laboratoire sécurité des
réseaux et protocoles. Le format d'échange utilisé pour archiver et
transmettre l'ensemble des annonces vues par une sonde est
\emph{Multi-Threaded Routing Toolkit} (MRT)~\cite{rfc6396}.

Là encore, deux outils étaient utilisés pour analyser une grande
quantité de données au format MRT, le premier en C\footnote{Il est à
  noter que cet outil en C se terminait parfois de manière brutale sur
  certains fichiers sans aucune explication}, le second en OCaml. Il a
suffi de 4 jours pour décrire en \FAceSL les structures MRT
pertinentes pour les études menées au laboratoire et obtenir un outil
indépendant des deux autres, plus rapide que l'implémentation en OCaml
pré-existante et plus fiable que l'implémentation en C.

\TODO{nb de lignes de code, tableau de comparaison de l'efficacité}


\subsection{TAR}

Développée pour les besoin de cet article, la description avec \FAceSL
du format d'archive TAR en moins de~100~lignes a permis d'écrire
ensuite un outil pour lister une archive TAR en quelques lignes. Il ne
s'agit cependant pas d'une réelle application, mais uniquement d'un
exemple.


\section{Conclusion et perspectives}

\TODO{Les extensions du langage écrites en \texttt{camlp4} ressemblent
  à scapy / hachoir ?}

\TODO{Intérêt de la solution retenue : peu de lignes, très expressif,
  robuste (typage), efficace!}

\TODO{Impact d'OCaml 4 ?}

\TODO{Autres parsers: DNS, pcap, etc.}

\TODO{Question de l'automate et de l'animation}



\bibliographystyle{plain}
\bibliography{biblio,rfc}


\end{document}
