\documentclass[twoside]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes}
\usepackage[french]{babel}

\usepackage{url}
\usepackage{xspace}
\usepackage{array}
\usepackage[pdftex]{graphicx}
\usepackage{listings}
\lstset{language=Caml, basicstyle=\footnotesize,
  morekeywords={enum, alias, struct, union,
                asn1_alias,
                UnknownVal, with_lwt, Exception}}

\newcommand{\PType}{$\mathcal{PT}$\hspace*{-.3ex}ype\xspace}
\newcommand{\PTypes}{$\mathcal{PT}$\hspace*{-.3ex}ypes\xspace}


\title{Parsifal~: une solution pour écrire rapidement des \emph{parsers} binaires robustes et efficaces}
\author{Olivier Levillain$^{1,2}$}
\titlehead{Parsifal~: une solution pour écrire rapidement des \emph{parsers} binaires robustes et efficaces}
\authorhead{O. Levillain}
\affiliation{\begin{tabular}{rr} 
      \\ 1:  Agence nationale de la sécurité des systèmes d'information (ANSSI)
      \\ 2:  Télécom Sud Paris
    \end{tabular}
}


\begin{document}

\setcounter{page}{1}
\maketitle

\vspace*{-.2cm}

Dans le cadre de ses activités d'expertise, le laboratoire sécurité
des réseaux et protocoles de l'ANSSI est amené à étudier divers
protocoles de communication. L'étude fine de ces protocoles passe par
l'utilisation de \emph{parsers} (ou dissecteurs) permettant d'analyser
les messages binaires échangés lors d'une exécution du
protocole. L'expérience a montré qu'il fallait disposer d'outils
robustes et maîtrisés pour étudier et comprendre les comportements
d'un protocole donné, en particulier pour en détecter et caractériser
les anomalies. En effet, les implémentations disponibles sont parfois
limitées (refus de certaines options), laxistes (acceptation
silencieuse de paramètres erronés) ou fragiles (terminaison brutale du
programme pour des valeurs inattendues, qu'elles soient licites ou
non). Ce constat nous a conduit au développement d'outils, l'objectif
étant de développer \emph{rapidement} des dissecteurs \emph{robustes}
et \emph{performants}. Ce document décrit brièvement Parsifal, une
implémentation générique de \emph{parsers} binaires reposant sur le
pré-processeur \texttt{camlp4} d'OCaml.

Afin de mieux comprendre un protocole et la manière dont il est
utilisé \emph{in vivo}, le laboratoire s'intéresse notamment à
l'analyse de grands volumes de données issus de mesures réalisées sur
internet. Le point de départ de nos travaux sur les \emph{parsers}
binaires est un ensemble important de traces réseau contenant des
échanges suivant le protocole TLS (\emph{Transport Layer Security}~\cite{rfc5246})
mises à disposition par l'EFF (\emph{Electronic Frontier
  Foundation})~\cite{eckersley-obs1}. Ces mesures ont fait l'objet
d'une publication~\cite{acsac2012}. L'analyse de ces données pose
plusieurs difficultés. Tout d'abord, les fichiers à analyser
représentent un volume conséquent (180~Go dans le cas de notre analyse
de TLS). Ensuite, les informations à extraire sont contenues dans des
messages de structures complexes. Enfin, il s'agit de données brutes,
non filtrées, dont la qualité, voire l'innocuité, laisse parfois à
désirer.


\vspace*{-.2cm}
\section*{Description de Parsifal}

Parsifal est issu des besoins identifiés et de l'expérience acquise
dans l'écriture de \emph{parsers} pour des formats binaires. Il s'agit
d'une implémentation générique de \emph{parsers} reposant sur un
pré-processeur \texttt{camlp4} et sur une bibliothèque auxiliaire.

Le concept de base de Parsifal est la définition de «~types
enrichis~», les \PTypes, qui sont simplement des types OCaml
quelconques pour lesquels certaines fonctions sont fournies. Ainsi, un
\PType est défini par un type OCaml \texttt{t} décrivant le contenu à
\emph{parser}, par une fonction pour disséquer les objets depuis une
chaîne de caractères (\texttt{parse\_t}) et par des fonctions pour
exporter les objets sous forme binaire (\texttt{dump\_t}) ou dans une
représentation haut niveau utile aux fonctions d'affichage
(\texttt{value\_of\_t}).

On peut distinguer trois sortes de \PTypes. Tout d'abord, la
bibliothèque standard fournit des \PTypes de base (entiers, chaînes de
caractère, listes, etc.). Ensuite, il estpossible de construire des
\PTypes à partir de mots clés tels que \texttt{struct},
\texttt{union}, \texttt{enum}; pour ceux-ci, une description suffit au
pré-processeur pour générer automatiquement le type OCaml et les
fonctions correspondantes. Enfin, dans certains cas, il est nécessaire
d'écrire le type OCaml et les fonctions \texttt{parse\_t},
\texttt{dump\_t} et \texttt{value\_of\_t} à la main, pour gérer des
cas particuliers. Pour illustrer les deux premiers types de \PTypes,
voici une implémentation rudimentaire des messages TLS à l'aide de Parsifal:
\begin{lstlisting}
enum tls_content_type (8, Exception) =
  | 0x14 -> CT_ChangeCipherSpec     | 0x15 -> CT_Alert
  | 0x16 -> CT_Handshake            | 0x17 -> CT_ApplicationData

union record_content (Unparsed_Record) =
  | CT_Alert            -> Alert of array(2) of uint8
  | CT_Handshake        -> Handshake of binstring
  | CT_ChangeCipherSpec -> ChangeCipherSpec of uint8
  | CT_ApplicationData  -> ApplicationData of binstring

struct tls_record = {
  content_type : tls_content_type;
  record_version : tls_version;
  record_content : container[uint16] of record_content (content_type)
}
\end{lstlisting}

Le dernier bloc de code décrit ce qu'est un \emph{record} TLS, un
enregistrement (décrit à l'aide du mot clé \texttt{struct}) contenant
quatre champs: le type du contenu, la version du protocole, la taille
du contenu et le contenu lui-même. Pour le premier champ, il
existe~4~types de contenu, qui sont décrits par l'énumération
\texttt{tls\_content\_type} (anoncée par le mot clé \texttt{enum} du
premier bloc). Cette valeur est stockée sur un entier 8 bits, et si la
lecture de ce champ donne une valeur non énumérée, une exception sera
levée; c'est le sens des paramètres de l'énumération (\texttt{8} et
\texttt{Exception}).

La version TLS est stockée sur 16 bits: on utilise donc le \PType
prédéfini \texttt{uint16}. Comme il existe certaines versions connues,
on pourrait utiliser une énumération ici également, avec un
comportement plus laxiste face aux valeurs inconnues
(ajout d'un constructeur avec \texttt{UnknownVal}):
\begin{lstlisting}
enum tls_version (16, UnknownVal UnknownVersion) =
  | 0x0002 -> SSLv2      | 0x0300 -> SSLv3
  | 0x0301 -> TLSv1      | 0x0302 -> TLSv1_1
  | 0x0303 -> TLSv1_2
\end{lstlisting}

Les deux derniers champs du \emph{tls\_record} sont décrits ensemble
par un conteneur dont la longueur, variable, tient sur 16~bits. Le
contenu du message lui-même est décrit par le \PType
\texttt{record\_content}, qui prend un argument
(\texttt{content\_type}). En effet, \texttt{record\_content} est une
\texttt{union}, dont le contenu dépend d'un discriminant, ici le type
de contenu. Par exemple, une alerte contient~2~octets.


\vspace*{-.2cm}
\section*{Bilan de deux ans d'écriture de \emph{parsers} binaires}

Après avoir écrit plusieurs implémentations dans différents langages
(Python, C++, OCaml), nous avons développé Parsifal, une
implémentation générique de \emph{parsers} binaires reposant sur un
pré-processeur, qui remplit nos besoins: possibilité d'exprimer des
formats complexes, rapidité d'écriture, robustesse et
performances. Plusieurs protocoles réseau ont déjà été (au moins
partiellement) décrits à l'aide de Parsifal (TLS, DNS, BGP...), ainsi
que plusieurs formats de fichiers (TAR, PNG, JPG...).

Cette courte présentation de Parsifal n'a pas fait état d'autres
constructions pratiques pour le développeur: gestion des structures
ASN.1 DER, conteneurs personnalisés, champs de bits... Le
projet est disponible en tant que logiciel libre sur
\url{https://github.com/ANSSI-FR/parsifal}.


\vspace*{-.2cm}
\begin{thebibliography}{1}

\bibitem{eckersley-obs1}
P.~{E}ckersley and J.~{B}urns.
\newblock {A}n {O}bservatory for the {SSL}iverse, {T}alk at {D}efcon 18, 2010.

\bibitem{acsac2012}
O.~Levillain, A.~Ébalard, H.~Debar, and B.~Morin.
\newblock One {Y}ear of {SSL} {M}easurement.
\newblock ACSAC, 2012.

\bibitem{rfc5246}
T.~Dierks and E.~Rescorla.
\newblock {The Transport Layer Security Protocol Version~1.2}.
\newblock RFC 5246, 2008.

\end{thebibliography}

\end{document}
