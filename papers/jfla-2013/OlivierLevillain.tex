\documentclass[twoside]{article}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{actes}
\usepackage[french]{babel}

\usepackage{url}
\usepackage{array}
\usepackage{listings}
\lstset{language=Caml, basicstyle=\footnotesize,
  morekeywords={enum, alias, struct, union,
                asn1_alias,
                UnknownVal, with_lwt, Exception}}
\usepackage{xspace}
\newcommand{\FAceSL}{Parsifal\xspace}
\newcommand{\FAceSLTypes}{PTypes\xspace}
\newcommand{\FAceSLType}{PType\xspace}


\title{\FAceSL: utilisation de \texttt{camlp4} pour l'écriture rapide de \emph{parsers}}
\author{Olivier Levillain$^{1,2}$}
\titlehead{\FAceSL: écriture rapide de \emph{parsers} en \texttt{camlp4}}
\authorhead{O. Levillain}
\affiliation{\begin{tabular}{rr} 
      \\ 1:  Agence nationale de la sécurité des systèmes d'information (ANSSI)
      \\     51 boulevard Latour Maubourg, 75700 Paris 07 SP
      \\     {\tt olivier.levillain@ssi.gouv.fr} 
      \\ 2:  Télécom Sud Paris
      \\     9 rue Charles Fourier, 91011 Evry
    \end{tabular}
}


\begin{document}

\setcounter{page}{1}
\maketitle

Dans le cadre de ses activités d'expertise, le laboratoire sécurité
des réseaux et protocoles (LRP) de l'agence nationale de la sécurité
des systèmes d'information (ANSSI) est amené à étudier divers
protocoles de communication. L'étude fine de ces protocoles passe par
l'utilisation de \emph{parsers}, ou dissecteurs, de confiance permettant
d'analyser les messages échangés lors d'une exécution du protocole.

L'expérience a montré qu'il était nécessaire de disposer
d'implémentations indépendantes et robustes pour étudier et comprendre
les comportements d'un protocole donné, en particulier pour détecter
et caractériser les anomalies. En effet, les implémentations
disponibles de clients, serveurs ou dissecteurs sont parfois limitées
(refus de certaines options), laxistes (acceptation silencieuse de
paramètres erronés) ou fragiles (terminaison brutale du programme pour
des valeurs inattendues, qu'elles soient licites ou non).

Ce constat a conduit au développement d'outils, l'objectif étant de
développer \emph{rapidement} des dissecteurs \emph{robustes} et
\emph{efficaces}. Pour cela, plusieurs langages de programmation ont
été successivement utilisés (C, C++, python, OCaml). L'objet de ce
document est de présenter l'une de ces implémentations, reposant sur
le pré-processeur \texttt{camlp4} d'OCaml, et de la comparer avec les
autres. La section~\ref{sec:historique} présente l'historique du
projet et deux applications concernant TLS et BGP.  La
section~\ref{sec:description} donne un aperçu de l'ensemble des
constructions apportées par \FAceSL et la section~\ref{sec:tar}
présente un exemple complet d'utilisation de \FAceSL: le format
d'archive TAR. La section~\ref{sec:resultats} donne quelques chiffres
pour comparer les programmes utilisant \FAceSL avec d'autres
implémentations équivalentes. Enfin, la section~\ref{sec:resultats}
conclut cette article et présente les perspectives d'évolution.



\section{Historique du projet}
\label{sec:historique}


\subsection{Motivation initiale: analyser de nombreuses réponses TLS}
\label{sec:tls}

Le point de départ de ces travaux était l'analyse d'une quantité
importante (180~Go) de données récoltées concernant le protocole
SSL/TLS. SSL (\emph{Secure Sockets Layer}) et TLS (\emph{Transport
  Layer Security}) sont deux variantes d'un même protocole, dont la
dernière version est TLSv1.2~\cite{rfc5246}. Leur objectif est de
fournir un certain nombre de services pour sécuriser un canal de
communication:
\begin{itemize}
\item authentification unilatérale ou mutuelle;
\item confidentialité des données échangées de bout en bout;
\item intégrité des données de bout en bout.
\end{itemize}

SSL a initalement été mis au point par Netscape pour protéger les
connexions HTTP. Le résultat de cette association (HTTP~+~SSL) est
désigné par l'acronyme HTTPS. Même si SSL/TLS peut être utilisé pour
sécuriser d'autres protocoles applicatifs, HTTPS reste l'application
principale de la couche cryptographique SSL/TLS. C'est la raison pour
laquelle plusieurs équipes de recherche ont récemment entrepris des
collectes sur l'ensemble des serveurs HTTPS accessibles sur internet,
afin d'évaluer la qualité des réponses TLS apportées par tous ces
serveurs.

Afin de pouvoir interpréter correctement les différents types de
réponses, il est nécessaire de comprendre les différentes versions du
protocole (SSLv2, SSLv3, TLSv1.0, TLSv1.1 et TLSv1.2), qui apportent
chacune des subtilités dans les messages échangés. Parmi les messages
pertinents pour ce type d'étude, le message \texttt{Certificate}
contient la chaîne de certification permettant l'authentification du
serveur. Elle est composée de certificats X.509~\cite{rfc5280}, dont le
format repose sur l'ASN.1, une syntaxe pour encoder de manière
structurée des entiers, des chaînes de caractères ou encore des objets
binaires\footnote{Plus précisément, l'ASN.1 (\emph{Abstract Syntax
    Notation One}) permet de décrire de manière abstraite la structure
  d'un certificat X.509; l'encodage utilisé pour les certificat est le
  DER (\emph{Distinguished Encoding Rules}), une représentation
  concrète canonique de l'ASN.1.}, ce qui apporte une complexité
supplémentaire pour la dissection des messages.

Le laboratoire sécurité des réseaux et protocoles a mené des travaux
sur de nombreuses traces HTTPS depuis deux
ans. Les données utilisées proviennent de résultats mis à dispositions
par l'Electronic Frontier Foundation~\cite{eff-observatory,
  eckersley-obs1, eckersley-obs2} en 2010 et de collectes effectuées
en 2011. Les traces analysées
contiennent une très grande diversité de réponses, parfois
incohérentes ou non conformes. Face à cet imposant corpus, il était
difficile d'utiliser des outils existants pour extraire de manière
fiable l'information pertinente pour les analyses. En effet, les
implémentations existantes ont généralement un comportement inadapté à
l'analyse, qu'il s'agisse d'un comportement limité (refus de certaines
options), laxiste (acceptation silencieuse de paramètres erronés) ou
fragile (terminaison brutale du programme pour des valeurs
inattendues, qu'elles soient licites ou non).

Des outils spécifiques, maîtrisés par le laboratoire, ont donc été
développés pour analyser ce grand volume de données.


\subsection{Démarche de développement des outils}

Le premier \emph{parser} réalisé pour cette tâche a été écrit en
Python. Nous avons ainsi obtenu rapidement un prototype pour extraire
les premiers éléments des données. Cependant, ce premier programme
s'est révélé trop lent face au volume à traiter.

Une seconde implémentation a donc vu le jour, en C++. Celle-ci
reposait sur les \emph{templates} et la programmation objet, et
permettait d'obtenir un dissecteur flexible et efficace, mais au prix
d'une grande quantité de code à écrire et d'erreurs de programmation
parfois difficiles à diagnostiquer (fuites mémoire, erreurs de
segmentation).

Pour pallier ce manque de robustesse, le développement d'une troisième
version des outils a été entreprise, en OCaml. Afin de conserver la
flexibilité imaginée pour le second prototype, un langage spécifique a
été développé pour décrire les structures à disséquer. Les outils
résultants étaient expressifs, efficaces et plus fiables que la
version précédente. Malheureusement, à l'usage, si l'extensibilité
était réelle, elle nécessitait des développements fastidieux.

Finalement, une nouvelle implémentation en OCaml a été réalisée pour
réunir l'ensemble des qualités recherchées pour le développement de
\emph{parsers}:
\begin{itemize}
\item rapidité de développement;
\item garanties fortes sur la robustesse et la correction;
\item efficacité des programmes (en temps comme en consommation mémoire).
\end{itemize}
\noindent
Cette quatrième mouture, baptisée \FAceSL, résulte de la fusion entre le
langage spécifique de description des objets analysés et le langage de
programmation: on utilise directement le langage OCaml pour les deux
usages. Pour cela, le processeur \texttt{camlp4} est employé pour
générer automatiquement des types et des fonctions à partir de
descriptions brèves des structures à disséquer.


\subsection{Autre application: MRT}
\label{sec:mrt}

BGP (\emph{Border Gateway Protocol}~\cite{rfc4271}) est un autre
protocole étudié par le laboratoire. Il s'agit du protocole de routage
utilisé pour interconnecter les différents réseaux qui forment
l'internet. Il existe de nombreuses RFC\footnote{Les RFC (\emph{Request For Comments}) sont des documents publiés par l'IETF (\emph{Internet Engineering Task Force}) qui décrivent entre autres les protocoles réseau de l'internet.} décrivant BGP, ses extensions,
ainsi que des protocoles connexes. En particulier, MRT
(\emph{Multi-Threaded Routing Toolkit}~\cite{rfc6396}) est un format
d'échange utilisé pour archiver et transmettre l'ensemble des annonces
vues par un routeur.

Certains projets proposent d'accéder aux informations de routage de
l'internet collectées depuis plusieurs points dans le monde, et
exportées au format MRT. Ces données sont d'un grand intérêt pour
analyser l'état de l'internet, détecter et comprendre d'éventuels
incidents affectant les informations de routage. L'observatoire de la
résilience de l'internet français~\cite{observatoire}, mis en place
par l'ANSSI en 2012, utilise de telles sources de données et doit
disposer d'outils capables d'interpréter les fichiers MRT. Le projet
RIS (\emph{Routing Information Service}) fournit trois fois par jour
une vision complète de~16~routeurs disséminés sur la planète, ce qui
correspond à plusieurs centaines de méga-octets par jour, d'où le
besoin d'avoir des dissecteurs efficaces.

Deux outils étaient utilisés au sein du laboratoire pour analyser
cette grande quantité de données au format MRT. Le premier est un
outil libre écrit en C, dont la qualité de code laisse à
désirer\footnote{Cet outil en C se terminait parfois de manière
  brutale sur certains fichiers sans donner aucune explication.}. Le
second est un développement interne en OCaml, plus fiable que le
premier.

Afin de valider la possibilité d'écrire rapidement avec \FAceSL des
\emph{parsers} efficaces et robustes, un nouveau développement des
outils d'analyse pour MRT a été réalisé. Il a suffi de~4~jours pour
décrire en \FAceSL les structures pertinentes pour les études menées
et obtenir un outil indépendant des deux autres, plus rapide que
l'implémentation en OCaml pré-existante et plus fiable que
l'implémentation~C.



\section{Description des extensions du langage}
\label{sec:description}

L'idée générale de \FAceSL est d'interpréter des descriptions courtes
utilisant de nouveaux mots-clés (\texttt{enum}, \texttt{struct},
\texttt{union}, \texttt{alias}) pour générer
automatiquement:
\begin{itemize}
\item des types OCaml décrivant les structures binaires
  correspondantes;
\item des fonctions pour disséquer les objets correspondants depuis
  une chaîne de caractère (\texttt{parse\_t}) ou depuis un flux Lwt
  (\texttt{lwt\_parse\_t});
\item des fonctions pour exporter les objets sous forme binaire
  (\texttt{dump\_t}) ou dans une représentation imprimable
  (\texttt{print\_t}).
\end{itemize}

\noindent
Le prototype de chacune de ces fonctions est:
\begin{lstlisting}
val parse_t : string_input -> t
val lwt_parse_t : lwt_input -> t
val dump_t : t -> string
val print_t : ?indent:string -> ?name:string -> t -> string
\end{lstlisting}

Les fonctions \texttt{parse} travaillent sur des chaînes
de caractères alors que \texttt{lwt\_parse} utilisent les flux issus
de la Lwt~\cite{lwt}, une bibliothèque implémentant des
threads synchrones à l'aide d'une interface monadique.

La fonction \texttt{print} accepte des options pour modifier
l'indentation et le nom de la structure à afficher. De plus, les fonctions
\texttt{parse}, \texttt{lwt\_parse} et \texttt{dump} peuvent
éventuellement accepter des paramètres supplémentaires.

\medskip

Les sections suivantes décrivent les différentes constructions
apportées par \FAceSL, et des exemples permettant de comprendre ce
qu'elles apportent. La grammaire détaillée est donnée en annexe.


\subsection{\'Enumérations}

La première construction ajoutée par \FAceSL est l'énumération, qui
ressemble à l'\texttt{enum} du C, le typage fort en plus. Par exemple,
la déclaration suivante:
\begin{lstlisting}
enum tls_version (16, UnknownVal V_Unknown, [with_lwt]) =
  | 0x0002 -> V_SSLv2, "SSLv2"
  | 0x0300 -> V_SSLv3, "SSLv3"
  | 0x0301 -> V_TLSv1, "TLSv1.0"
  | 0x0302 -> V_TLSv1_1, "TLSv1.1"
  | 0x0303 -> V_TLSv1_2, "TLSv1.2"
\end{lstlisting}

\noindent correspond au champ encodant la version du protocole SSL/TLS
sur un entier~16~bits, et génère le type somme suivant:
\begin{lstlisting}
type tls_version =
  | V_SSLv2 | V_SSLv3 | V_TLSv1 | V_TLSv1_1 | V_TLSv1_2
  | V_Unknown of int
\end{lstlisting}

\noindent ainsi que les fonctions suivantes:
\begin{lstlisting}
val string_of_tls_version : tls_version -> string
val int_of_tls_version : tls_version -> int
val tls_version_of_int : int -> tls_version
val tls_version_of_string : string -> tls_version

val parse_tls_version : string_input -> tls_version
val lwt_parse_tls_version : lwt_input -> tls_version
val dump_tls_version : tls_version -> string
val print_tls_version : ?indent:string -> ?name:string -> tls_version -> string
\end{lstlisting}

En plus des quatre fonctions annoncées plus haut, les quatre premières
fonctions générées permettent simplement de convertir le type
énumération depuis et vers les entiers et les chaînes de
caractères. Il est possible de décrire comment
\texttt{tls\_version\_of\_int} doit traiter une valeur non fournie
dans l'énumération: dans l'exemple ci-dessus, \texttt{UnknownVal
  V\_Unknown} indique qu'il faut renvoyer une valeur
\texttt{V\_Unknown i}, où \texttt{i} est la valeur non
reconnue. L'autre comportement possible est de lever une exception en
cas de motif inconnu.


\subsection{\FAceSLTypes}

Avant de poursuivre avec les constructions apportées par \FAceSL, il
est nécessaire de décrire les \FAceSLTypes, les types binaires compris
par \texttt{struct}, \texttt{union} et \texttt{alias}.

\medskip

Tout d'abord, \FAceSL propose des types de base pour lesquels les
implémentations des fonctions \texttt{parse}, \texttt{lwt\_parse},
\texttt{dump} et \texttt{print} sont déjà disponibles: les entiers et
les chaînes de caractères.

En plus de ces types scalaires, le \FAceSLType \texttt{list} permet de
décrire des listes d'objets du même type et \texttt{container}
sert à encapsuler un sous-type en spécifiant la taille de la
sous-chaîne à lire depuis l'entrée.

\medskip

Pour les chaînes de caractères et les listes, les \emph{parsers}
générés par défaut essaient de lire l'ensemble de la chaîne qui leur
est passée en entrée. On peut cependant préciser avec une expression
entre parenthèses la taille en octets attendue pour une chaîne de
caractères en octets ou le nombre d'éléments attendus pour une liste
(\texttt{string(10)} correspond ainsi à une chaîne de 10~caractères).

Parfois, une chaîne de caractères ou une liste a une taille variable,
spécifiée par un champ longueur le ou la précédent. Avec \FAceSL, on peut spécifier à l'aide de crochets qu'un tel type est
attendu: \texttt{\textbf{list} [uint16] \textbf{of} uint16} permet de
décrire une liste d'entiers sur 16~bits dont la longueur totale en
octets est codées sur un entier 16~bits\footnote{Ce type particulier
  peut servir à décrire la liste des suites cryptographiques
  (\emph{ciphersuites}) proposées par un client dans le protocole
  TLS.}.

\medskip

Enfin, n'importe quel type peut être utilisé comme \FAceSLType personnalisé,
dès lors qu'il s'agit d'un type OCaml, et que les fonctions
\texttt{parse}, \texttt{dump} et \texttt{print} correspondantes
existent. Il existe deux moyens de construire de nouveaux types:
\begin{itemize}
\item en écrivant un nouveau type OCaml et les fonctions nécessaires;
\item à l'aide de \texttt{struct} et \texttt{union}.
\end{itemize}

Pour illustrer le premier point, prenons un exemple tiré de MRT,
présenté dans la section~\ref{sec:mrt}. De nombreux champs du
protocole BGP sont des adresses IPv4 et IPv6 encodées directement en
binaires, respectivement sur 32 et 128~bits. Le code suivant montre comment ajouter
\texttt{ipv4} à l'arsenal des \FAceSLTypes disponibles:
\begin{lstlisting}
type ipv4 = string

let parse_ipv4 input = parse_string 4 input
let lwt_parse_ipv4 input = lwt_parse_string 4 input

let dump_ipv4 ipv4 = ipv4

let print_ipv4 ?indent:(indent="") ?name:(name="ipv4") s =
  let res = string_of_ipv4 s in
  Printf.sprintf "%s%s: %s\n" indent name res
\end{lstlisting}

L'autre manière de créer un \FAceSLType consiste à utiliser les mots-clés \texttt{struct} et
\texttt{union} pour décrire des types complexes à partir de
\FAceSLTypes existant, qui sont décrits dans les paragraphes suivants.


\subsection{Structures}

Les structures que l'on peut décrire avec \FAceSL sont des
enregistrements qui viennent avec des fonctions \texttt{parse},
\texttt{dump} et \texttt{print} auto-générées. Afin de présenter le fonctionnement du mot-clé \texttt{struct}, on
peut s'intéresser à la manière d'implémenter les messages d'alerte
TLS. Ces messages sont spécifiés de la manière suivante dans
TLSv1.2~\cite{rfc5246} (pages 27 et 28):
\begin{verbatim}
enum { warning(1), fatal(2), (255) } AlertLevel;

enum {
    close_notify(0),
    unexpected_message(10),
     ...
    unsupported_extension(110),
    (255)
} AlertDescription;

struct {
    AlertLevel level;
    AlertDescription description;
} Alert;
\end{verbatim}

Ces messages sont simplement composés d'un octet décrivant le niveau
de l'alerte et d'un second octet décrivant le type d'alerte. Pour
implémenter cette spécification en \FAceSL, il suffit de créer deux
types énumérations sur 8~bits, puis de créer un type enregistrement,
comme dans le code suivant:
\begin{lstlisting}
enum tls_alert_level (8, UnknownVal AL_Unknown, []) =
  | 1 -> AL_Warning, "Warning"
  | 2 -> AL_Fatal, "Fatal"

enum tls_alert_type (8, UnknownVal AT_Unknown, []) =
  | 0 -> AT_CloseNotify, "CloseNotify"
  | 10 -> AT_UnexpectedMessage, "UnexpectedMessage"
    ...
  | 110 -> AT_UnsupportedExtension, "UnsupportedExtension"

struct tls_alert =
{
  alert_level : tls_alert_level;
  alert_type : tls_alert_type
}
\end{lstlisting}

Une fois ces quelques lignes écrites, qui sont essentiellement une
reformulation de la spécification, il est directement possible
d'utiliser les fonctions générées telles que
\texttt{parse\_tls\_alert}.


\subsection{Unions}

Empruntant encore à la terminologie du langage C, les unions de \FAceSL sont en
réalité des types somme augmentés par un constructeur par
défaut. L'idée est d'utiliser un discriminant passé en argument à la
fonction \texttt{parse} pour en déduire le constructeur du type somme
à utiliser. Ce discriminant va être comparé aux différents motifs
proposés dans la description de l'union, et le constructeur adapté
sera choisi.

Pour illustrer ce concept, prenons un exemple issu du format MRT. Pour
décrire les différents systèmes interconnectés par BGP, on utilise la
notion de système autonome (AS, \emph{Autonomous Systems}), un numéro identifiant un
opérateur. Initialiement, ces AS étaient représentés sur 16~bits, mais
cela n'est plus suffisant désormais et les AS sont parfois décrits sur
32~bits. L'exemple suivant montre comment décrire un AS avec une
union, et comment employer le type généré dans une structure:
\begin{lstlisting}
union autonomous_system (UnparsedAS, [enrich]) =
  | 16 -> AS16 of uint16
  | 32 -> AS32 of uint32

struct bgp_as_path_segment [param as_size] =
{
  path_segment_type : uint8;
  path_segment_length : uint8;
  path_segment_value : list(path_segment_length) of autonomous_system(as_size)
}
\end{lstlisting}

Le type \texttt{autonomous\_system} sera vu comme un
entier~16~ou~32~bits selon le discriminant qui lui est passé. La
déclaration de la structure \texttt{bgp\_as\_path\_segment} conduit à
la génération d'une fonction \texttt{parse\_bgp\_as\_path\_segment}
qui prend un argument supplémentaire (\texttt{as\_size}), puis tente
de lire le type de segment (un octet), la longueur du segment (un
autre octet), puis une liste contenant \texttt{path\_segment\_length}
éléments du type union défini. On remarquera que la valeur
\texttt{as\_size} est alors passée comme discriminant à
\texttt{parse\_autonomous\_system}.

Voici des extraits du code OCaml généré par \FAceSL à partir des deux
types ci-dessus:
\begin{lstlisting}
type autonomous_system = | AS16 of int | AS32 of int | UnparsedAS of string

let parse_autonomous_system discriminator input =
  match discriminator with
    | 16 -> AS16 (parse_uint16 input)
    | 32 -> AS32 (parse_uint32 input)
    | _ -> UnparsedAS (parse_rem_string input)

type bgp_as_path_segment =
{
  path_segment_type : int;
  path_segment_length : int;
  path_segment_value : autonomous_system list
}

let parse_bgp_as_path_segment as_size input =
  let path_segment_type = parse_uint8 input in
  let path_segment_length = parse_uint8 input in
  let path_segment_value = parse_list path_segment_length
      (parse_autonomous_system as_size) input
  in
    {
      path_segment_type = path_segment_type;
      path_segment_length = path_segment_length;
      path_segment_value = path_segment_value;
    }
\end{lstlisting}

% TODO: ~enrich should be Default|AlwaysOn|AlwaysOff|OnForDepth of int


\subsection{Autres constructions}

\FAceSL propose d'autres mots-clés et fonctionnalités, qui ne seront
pas décrits en détails ici:
\begin{itemize}
\item pour permettre de produire simplement des fonctions
  \texttt{parse}, \texttt{dump} et \texttt{print} pour des listes, on
  peut déclarer des alias avec le mot clé \texttt{alias};
\item afin de permettre la description de structures ASN.1 encodées au
  format DER (par exemple les certificats X.509), \FAceSL fournit des
  types prédéfinis et un mot-clé \texttt{asn1\_alias};
\item parfois, la dissection de messages complexes ne requiert pas une
  dissection en profondeur de toutes les structures. Afin d'accélérer
  les outils, il est possible de désactiver l'enrichissement des
  unions non pertinentes à l'aide d'un paramètre \texttt{enrich}.
\end{itemize}


\section{Exemple d'un développement avec \FAceSL: le format TAR}
\label{sec:tar}

\subsection{Présentation du format}

TAR est un format d'archive classique utilisé dans le monde Unix. Son
rôle est d'agréger un ensemble de fichiers à archiver dans un seul
gros fichier, qui pourra éventuellement être compressé ensuite.

Une archive s'organise en une succession d'entrées, dont le contenu
est décrit dans la table~\ref{tab:tar-entry}. Chaque entrée commence
par un en-tête dont les champs varient en fonction de la version du
format utilisée; la table~\ref{tab:tar-format} décrit deux de ces
versions: le format original (colonne TAR) et une variante plus
récente (colonne \texttt{ustar}). L'en-tête est contenu dans un
«~bloc~» de 512~octets, et le contenu du fichier qui suit l'en-tête
est lui-aussi complété par des caractères nuls pour former des blocs
de 512~octets.

TAR présente une particularité quant au stockage des valeurs entières:
celles-ci sont systématiquement stockées sous la forme d'une chaîne de
caractère représentant la valeur numérique en octal. Cette méthode
permet d'éviter des difficultés d'encodage telles que la prise en
compte de l'\emph{endianness}, mais au prix d'une plus grande
consommation mémoire.

Le champ à l'offset~156 décrit le type de fichier. La table
\ref{tab:tar-filetypes} récapitule les différentes valeurs qu'il peut
prendre (dont certaines sont uniquement accessibles avec le format
étendu \texttt{ustar}). En fonction de la valeur prise par ce champ,
certains des champs de l'en-tête ne sont pas pertinents et devront
être remplis de caractères nuls.

\begin{table}
  \begin{center}
    \begin{tabular}{|r|r|l|}
      \hline
      \multicolumn{1}{|c|}{\bf Offset} &
      \multicolumn{1}{c|}{\bf Long.} &
      \multicolumn{1}{c|}{\bf Description} \\
      \hline

      \hline
        0 & 512 & En-tête TAR, complété par des zéros \\
      \hline
      512 & \multicolumn{1}{c}{\emph{«~Taille du fichier~»}} &
      Contenu du fichier, complété par des zéros \\
      & \multicolumn{1}{c}{alignée à 512~octets} & \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Description d'une entrée TAR.}
  \label{tab:tar-entry}
\end{table}

\begin{table}
  \begin{center}
    \begin{tabular}{|r|r|l|l|}
      \hline
      \multicolumn{1}{|c|}{\bf Offset} &
      \multicolumn{1}{c|}{\bf Long.} &
      \multicolumn{2}{c|}{\bf Description} \\
      & & \multicolumn{1}{c|}{\bf TAR} &
      \multicolumn{1}{c|}{\bf \tt ustar} \\
      \hline

      \hline
        0 & 100 & \multicolumn{2}{l|}{Nom du fichier} \\
      \hline
      100 &   8 & \multicolumn{2}{l|}{Permissions} \\
      \hline
      108 &   8 & \multicolumn{2}{l|}{UID} \\
      \hline
      116 &   8 & \multicolumn{2}{l|}{GID} \\
      \hline
      124 &  12 & \multicolumn{2}{l|}{Taille du fichier} \\
      \hline
      136 &  12 & \multicolumn{2}{l|}{\emph{Timestamp} de la dernière modification} \\
      \hline
      148 &   8 & \multicolumn{2}{l|}{Somme de contrôle de l'en-tête} \\
      \hline
      156 &   1 & Indicateur de lien & Type de fichier \\
      \hline
      157 & 100 & \multicolumn{2}{l|}{Nom du fichier pointé par le lien} \\
      \hline
      257 &   6	& \multicolumn{1}{c|}{-} & Indicateur \texttt{"ustar"} \\
      \hline
      263 &   2	& \multicolumn{1}{c|}{-} & Version \texttt{ustar} ("00") \\
      \hline
      265 &  32 & \multicolumn{1}{c|}{-} & Propriétaire \\
      \hline
      297 &  32 & \multicolumn{1}{c|}{-} & Groupe propriétaire \\
      \hline
      329 &   8 & \multicolumn{1}{c|}{-} & Numéro majeur du périphérique \\
      \hline
      337 &   8 & \multicolumn{1}{c|}{-} & Numéro mineur du périphérique \\
      \hline
      345 & 155 & \multicolumn{1}{c|}{-} & Préfixe \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Description de l'en-tête TAR.}
  \label{tab:tar-format}
\end{table}

\begin{table}
  \begin{center}
    \begin{tabular}{|>{\tt}c|l|c|}
      \hline
      \multicolumn{1}{|c|}{\bf Caractère} &
      \multicolumn{1}{c|}{\bf Description} &
      \multicolumn{1}{c|}{\bf Spécifique à \tt ustar} \\
      \hline

      \hline
      <NUL>, 0 & fichier ordinaire & - \\
      1 & lien dur & - \\
      2 & lien symbolique & - \\
      \hline
      3 & périphérique en mode caractères & oui \\
      4 & périphérique en mode blocs & oui \\
      5 & répertoire & oui \\
      6 & file FIFO & oui \\
      7 & fichier contigu & oui \\
      \hline
    \end{tabular}
  \end{center}

  \caption{Valeurs du champ «~Indicateur de lien/Type de fichier~».}
  \label{tab:tar-filetypes}
\end{table}


\subsection{Une première implémentation}

Afin d'utiliser \FAceSL pour décrire les fichiers au format TAR,
commençons par décrire les valeurs du champ «~Indicateur de lien/Type
de fichier~». Il s'agit d'une énumération sur 8~bits qui s'écrit
logiquement avec le nouveau mot-clé \texttt{enum}:
\begin{lstlisting}
enum file_type (8, UnknownVal UnknownFileType, []) =
  | 0 -> NormalFile
  | 0x30 -> NormalFile
  | 0x31 -> HardLink
  | 0x32 -> SymbolicLink
  | 0x33 -> CharacterSpecial
  | 0x34 -> BlockSpecial
  | 0x35 -> Directory
  | 0x36 -> FIFO
  | 0x37 -> ContiguousFile
\end{lstlisting}

Ensuite, on peut décrire l'enregistrement contenant les différents
champs constituant d'un en-tête à l'aide du mot clé \texttt{struct} de
la manière suivante:
\begin{lstlisting}
struct tar_header =
{
  file_name : string(100);
  file_mode : string(8);
  owner_uid : string(8);
  owner_gid : string(8);
  file_size : string(12);
  timestamp : string(12);
  checksum  : string(8);
  file_type : file_type;
  linked_file : string(100);
  ustar_magic : magic("ustar\x0000");
  owner_user : string(32);
  owner_group : string(32);
  device_major : string(8);
  device_minor : string(8);
  filename_prefix : string(155);
  hdr_padding : binstring(12);
}
\end{lstlisting}

On obtient alors un type enregistrement \texttt{tar\_header}. Il
contient en particulier un champ \texttt{file\_size} de type chaîne de
caractères, encodant la taille du fichier en octal. Comme la valeur entière
est nécessaire pour savoir combien d'octets lire pour le contenu du
fichier, il nous faut une fonction de conversion\footnote{Pour des
  raisons historiques, les chaînes de caractères décrivant la
  représentation en octal des valeurs numériques se terminent par un
  espace ou un caractère nul, ne laissant ainsi en pratique que
  7~octets pour encoder la valeur.}:
\begin{lstlisting}
let int_of_tarstring octal_value =
  let len = String.length octal_value in
  if len = 0
  then 0
  else begin
    let real_octal_value = String.sub octal_value 0 (len -1) in
    int_of_string ("0o" ^ octal_value)
  end
\end{lstlisting}

Il ne nous reste plus qu'à finaliser l'implémentatin en décrivant ce
qu'est une entrée TAR et en créant un alias décrivant un fichier:
\begin{lstlisting}
struct tar_entry =
{
  header : tar_header;
  file_content : binstring(int_of_tarstring header.file_size);
  file_padding : binstring(512 - ((int_of_tarstring header.file_size) % 512))
}

alias tar_file [with_lwt] = list of tar_entry;
\end{lstlisting}

Une fois ces quelques dizaines de lignes écrites, on dispose d'une
implémentation fonctionnelle pour disséquer, produire et afficher des
fichiers TAR. Il est par exemple possible d'utiliser les fonctions
générées par le pré-processeur pour lister le nom des fichiers
contenus dans une archive TAR. On utilise pour cela la fonction
\texttt{lwt\_parse\_tar\_file}:
\begin{lstlisting}
let handle_filename filename =
  Lwt_unix.openfile filename [Unix.O_RDONLY] 0 >>= fun fd
  lwt_parse_tar_file (input_of_fd filename fd) >>= fun tar_file
  let print_filename entry = print_string entry.file_name in
  List.iter print_filename tar_file;
  return ()

let _ =
  Lwt_unix.run (handle_filename "test.tar");
\end{lstlisting}

% TODO: décrire la compilation

Une fois ce programme compilé avec le pré-processeur \texttt{camlp4}
et lié avec les bibliothèques décrivant les fonctions de base, on peut
lancer le programme pour décrire le contenu de l'archive
\texttt{test.tar}.


\subsection{Traitement des vieilles archives}

Le type pré-défini \texttt{magic} utilisé dans la structure
\texttt{tar\_header} permet de lire un marqueur attendu (parfois
appelé \emph{magic} en anglais). Si le marqueur ne peut être trouvé,
la dissection échoue sur une erreur.

La première version proposée est fonctionnelle, mais si l'on souhaite
proprement prendre en compte les vieilles archives, ne contenant pas
l'en-tête étendu commençant par le marqueur \texttt{ustar}, on doit
réécrire la description de l'en-tête de la manière suivante, en
séparant l'en-tête en deux morceaux, dont un est déclaré
optionnel. Pour cela, on remplace les déclarations de
\texttt{tar\_header} et \texttt{tar\_entry} par le code suivant:
\begin{lstlisting}
struct ustar_header =
{
  ustar_magic : magic("ustar\x0000");
  owner_user : string(32);
  owner_group : string(32);
  device_major : string(8);
  device_minor : string(8);
  filename_prefix : string(155);
}
\end{lstlisting}

\begin{lstlisting}
struct tar_header =
{
  file_name : string(100);
  file_mode : string(8);
  owner_uid : string(8);
  owner_gid : string(8);
  file_size : string(12);
  timestamp : string(12);
  checksum  : string(8);
  file_type : file_type;
  linked_file : string(100);
  optional ustar_header : ustar_header;
  hdr_padding : binstring;
}
\end{lstlisting}

\begin{lstlisting}
struct tar_entry =
{
  header : container(512) of tar_header;
  file_content : binstring(int_of_tarstring header.file_size);
  file_padding : binstring(512 - ((int_of_tarstring header.file_size) % 512))
}
\end{lstlisting}

Avec cette seconde version, on utilise un conteneur de 512 octets pour
lire l'en-tête. Si l'en-tête est étendu, le champ
\texttt{ustar\_header} sera complété par la fonction
\texttt{parse\_ustar\_header} et le champ \texttt{hdr\_padding}, une
chaîne binaire consommant les octets restants du conteneur,
contiendra~12~octets; dans le cas contraire, la fonction
\texttt{parse\_ustar\_header} échouera renvoyant \texttt{None} pour le
champ \texttt{ustar\_header} et \texttt{hdr\_padding} aura une
longueur de 255~octets.


\subsection{Prise en compte transparente des valeurs numériques
  octales}
\label{sec:octal-strings}

Le format TAR faisant un usage important des chaînes de caractères
encodant une valeur numérique en octal. Les deux implémentations
proposées ci-dessus encodent simplement ces champs comme une chaîne de
caractères d'une taille donnée. Afin d'améliorer l'ergonomie des types
construits, on pourrait créer de toute pièce un nouveau type,
\texttt{tar\_numstring} pour prendre en compte ce format
particulier. Il suffit pour cela de définir un nouveau type OCaml et les
fonctions associées:
\begin{lstlisting}
type tar_numstring = int

let parse_tar_numstring len input =
  let octal_value = parse_string (len - 1) input in
  drop_bytes 1 input;
  int_of_string ("0o" ^ octal_value)

let dump_tar_numstring len v =
  Printf.printf "%*.*o\x00" len len v

let print_tar_numstring ?indent:(indent="") ?name:(name="numstring") v =
  Printf.sprintf "%s%s: %d (%o)\n" indent name v v
\end{lstlisting}

Une fois ce nouveau \FAceSLType défini, on peut modifier les champs
représentant des valeurs numériques en octal (comme
\texttt{file\_size}) en replaçant le type \texttt{string(n)} par
\texttt{tar\_numstring(n)}. Cela nécessite de reprendre la définition
de \texttt{ustar\_header} et de \texttt{tar\_header}; ensuite, la
description de \texttt{tar\_entry} se simplifie puisque
\texttt{header.file\_size} est désormais de type
\texttt{tar\_numstring}, c'est-à-dire un entier\footnote{La fonction \texttt{int\_of\_tarstring}
  définie plus haut devient alors inutile.}:
\begin{lstlisting}
struct tar_entry =
{
  header : container(512) of tar_header;
  file_content : binstring(header.file_size);
  file_padding : binstring(512 - (header.file_size % 512))
}
\end{lstlisting}



\section{Quelques résultats}
\label{sec:resultats}

\FAceSL fournit les \FAceSLTypes suivants: les types scalaires de base
(entiers, chaînes de caractères), les types liste et conteneur,
quelques types utiles (\texttt{magic}, \texttt{ipv4}, etc.) et les
types ASN.1 de base. Pour cela, l'implémentation repose sur
\begin{itemize}
\item des pré-processeurs \texttt{camlp4}, qui comportent environ
  1200~lignes de code;
\item des bibliothèques annexes pour implémenter la gestion des
  \FAceSLTypes, sur 1300~lignes de code.
\end{itemize}

% Ce travail a nécessité de comprendre le fonctionnement de
% \texttt{camlp4} dont la documentation n'est pas toujours facile
% d'accès, mais une fois les différents types de \texttt{camlp4}
% assimilés, il est possible de réaliser des manipulations extrêmement
% riches sur l'arbre de syntaxe abstraite.

% Pour la présentation
% \TODO{Comportement surprenant: camlp4o <preprocessors> <fichier.ml> a
%   un comportement différent selon que la sortie standard est un pipe
%   ou une console...}


Comme indiqué plus haut, plusieurs formats et protocoles suivants ont
été implémentés à partir de ces briques de base:
\begin{itemize}
\item les certificats X.509 (100~lignes);
\item les messages du protocole TLS (600~lignes);
\item les messages du protocole MRT (300~lignes);
\item le format TAR, pour les besoins de cet article (moins de 100~lignes).
\end{itemize}

\medskip

Une fois ces formats et protocoles décrits, il est possible d'écrire
des outils utilisant les fonctions \texttt{parse}, \texttt{dump} et
\texttt{print}. Parmi ces outils, citons-en deux issus des études
décrites dans les sections~\ref{sec:tls}~et~\ref{sec:mrt}:
\begin{itemize}
\item un outil pour extraire les certificats des réponses TLS (\texttt{answer2certs});
\item un programme pour afficher les annonces de route BGP à partir
  d'un fichier MRT (\texttt{mrtdump}).
\end{itemize}

Pour ces deux applications, nous disposons de plusieurs
implémentations dans différents langages. Le tableau suivant
récapitule le nombre de lignes et le temps d'exécution sur des données
caractéristiques des différentes implémentations:
\begin{center}
\begin{tabular}{l||l|r|r|r|}
& \multicolumn{1}{c|}{C ou C++} & \multicolumn{1}{c|}{OCaml} & \multicolumn{1}{c|}{OCaml + \FAceSL\footnotemark} \\
\hline
\hline
\texttt{answer2certs} & \multicolumn{1}{c|}{Dev. interne (C++)} &
                        \multicolumn{1}{c|}{Dev. interne} &
                        \multicolumn{1}{c|}{Dev. interne} \\
\multicolumn{1}{r||}{Nb lignes} & 8~500 & 4~000  & 1~000 \\
\multicolumn{1}{r||}{Temps}     & 100~s & 40~s   & 8~s   \\
\hline
\texttt{mrtdump} & \multicolumn{1}{c|}{\texttt{libbgpdump}\footnotemark} &
                        \multicolumn{1}{c|}{Dev. interne} &
                        \multicolumn{1}{c|}{Dev. interne} \\
\multicolumn{1}{r||}{Nb lignes} & 4~000 & 1~200  & 550  \\
\multicolumn{1}{r||}{Temps}     & 23~s & 180~s   & 35~s \\
\hline
\end{tabular}
\end{center}
\addtocounter{footnote}{-1}
\footnotetext{Pour la colonne «~OCaml + \FAceSL~», le décompte ne
  comprend ni le pré-processeur ni les fonctions auxiliaires de base.}
\addtocounter{footnote}{1}
\footnotetext{Le projet \texttt{bgpdump} est disponible à l'adresse \url{www.ris.ripe.net/source/bgpdump}.}

Dans tous les cas, on constate que l'implémentation utilisant \FAceSL
requiert bien moins de lignes de code que les implémentations
équivalentes étudiées. Du point de vue des performances, il est
intéressant de constater que l'implantation initiale en C++ de
\texttt{answer2certs} n'était pas très bonne, alors que sa réécriture
en OCaml puis avec \FAceSL se sont révélées non seulement plus
succinctes, mais aussi beaucoup plus rapide; en revanche,
l'implémantation disponible sur étagère pour disséquer des fichiers
MRT en C est 33~\% plus rapide que la version reposant sur \FAceSL,
mais les deux versions ne sont pas tout à fait iso-fonctionnelles,
puisque certains fichiers MRT font échouer \texttt{libbgpdump} alors
que nos développements les traitent correctement.


% \begin{itemize}
% \item énumérations TLS\footnote{L'énumération décrivant l'ensemble des
%     suites cryptographiques comporte en particulier~300~valeurs.}:
%   500~lignes;
% \item description des messages TLS: 150~lignes;
% \item description des certificats X.509 : 100~lignes;
% \item outil pour tester les versions et suites cryptographiques
%   supportées par un serveur donné, et afficher la partie en clair de
%   l'échange: 250~lignes.
% \end{itemize}

% Ainsi, en environ 1000~lignes de code\footnote{Ce décompte ne comprend
%   évidemment pas le pré-processeur ni les fonctions auxiliaires
%   fournissant les services de base (\texttt{parse\_uint8} et
%   \texttt{dump\_list} par exemple).}, il a été possible de décrire une
% grande partie du protocole TLS ainsi qu'un outil de test.



% La description des messages MRT nécessite moins de~300~lignes de code,
% alors que l'outil permettant d'afficher le contenu disséqué de manière
% similaire aux outils existants en comporte~250. L'implémentation
% précédente en OCaml comptait~1200 lignes environ.



\section{Conclusion et perspectives}
\label{sec:conclusion}

Pour remplir sa mission de compréhension des protocoles réseau, le
laboratoire sécurité des réseaux et protocoles a développé plusieurs
outils de dissection de protocoles. Parmi ceux-ci, \FAceSL est une
implémentation générique de \emph{parsers} reposant sur un
pré-processeur \texttt{camlp4} et sur une bibliothèque
auxiliaire. Avec ses~2500~lignes de code, \FAceSL permet de générer
des dissecteurs réunissant toutes les propriétés recherchées (rapidité
de développement, garanties fortes sur la robustesse et la correction
et efficacité des programmes).

Deux projets écrits en Python présentent des similarités avec les
travaux exposés ici:
\begin{itemize}
\item \texttt{scapy}~\cite{scapy}, une boîte à outils pour manipuler les paquets
  réseau; ce projet permet également de définir rapidement de nouveaux
  protocoles réseau pour étendre la boîte à outils;
\item \texttt{hachoir}~\cite{hachoir}, une bibliothèque pour écrire rapidement des
  dissecteurs pour des formats de fichiers.
\end{itemize}
\noindent Le langage Python semble un candidat naturel pour réaliser
ce genre de projet, grâce à ses capacités d'introspection. Il est
intéressant de remarquer que l'utilisation d'un pré-processeur OCaml
permet d'arriver au même résultat.

\medskip

Parmi les développements prévus pour \FAceSL, les pistes suivantes
sont envisagées:
\begin{itemize}
\item détailler les extensions des certificats X.509 qui ne sont que
  partiellement enrichies aujourd'hui;
\item écrire et animer l'automate du protocole de négociation TLS (à
  ce jour, seule une animation rudimentaire a été déveoppée);
\item pour disposer d'une pile TLS complète, ajouter les appels aux
  fonctions cryptographiques pour mettre réellement en \oe uvre le
  tunnel négocié;
\item décrire de nouveaux formats de fichiers et de nouveaux
  protocoles (DNS, OCSP) ou formats de fichiers (fichiers de traces
  réseau \texttt{pcap}, format exécutable PE);
\end{itemize}

%\item automatisation de TODO{l'animation} des protocoles par la génération
%  d'automates permettant l'étude d'exécutions du protocoles.

%\TODO{ASN.1: ajout d'options, ajout des unions et de spécifités}


\bibliographystyle{unsrt}
\bibliography{biblio,rfc}


\appendix
\section{Annexe: grammaire des extensions}


\subsection{Options}

\shorthandoff{:}
\begin{tabbing}
  \textit{option} ::\= = \= \textbf{\tt with\_lwt} \\
  \> $\vert$ \> \textbf{\tt with\_exact}\footnotemark \\
  \> $\vert$ \> \textbf{\tt top}\addtocounter{footnote}{-1}\footnotemark \\
  \> $\vert$ \> \textbf{\tt param} \textit{expression}\addtocounter{footnote}{-1}\footnotemark \\
  \> $\vert$ \> \textbf{\tt enrich}\footnotemark \\
  \> $\vert$ \> \textbf{\tt exhaustive}\addtocounter{footnote}{-1}\footnotemark
\end{tabbing}
\shorthandon{:}
\addtocounter{footnote}{-1}\footnotetext{Ces options n'ont de sens
  que pour les structures, les unions et les alias.}
\addtocounter{footnote}{1}\footnotetext{Ces options n'ont de sens
  que pour les unions.}


\subsection{\FAceSLTypes}

\shorthandoff{:}
\begin{tabbing}
  \textit{\FAceSLType} ::\= = \= \textbf{\tt char} \\
  \> $\vert$ \> \textbf{\tt uintN} \\
  \> $\vert$ \> \textbf{\tt string} \\
  \> $\vert$ \> \textbf{\tt string} (\textit{expression}) \\
  \> $\vert$ \> \textbf{\tt string} [\textit{type entier}] \\
  \> $\vert$ \> \textbf{\tt binstring} \\
  \> $\vert$ \> \textbf{\tt binstring} (\textit{expression}) \\
  \> $\vert$ \> \textbf{\tt binstring} [\textit{type entier}] \\
  \> $\vert$ \> \textbf{\tt list} \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt list} (\textit{expression}) \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt list} [\textit{type entier}] \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt container} (\textit{expression}) \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textbf{\tt container} [\textit{type entier}] \textbf{\tt of} \textit{\FAceSLType} \\
  \> $\vert$ \> \textit{type personnalisé} \\
  \> $\vert$ \> \textit{type personnalisé} (\textit{paramètres})
\end{tabbing}

% check ?

\subsection{Énumérations}

\shorthandoff{:}
\begin{tabbing}
  \textit{énumération} ::= \textbf{\tt enum} \= \textit{identifiant} (taille : \textit{int},
                                                                      \textit{comportement\_enum},
                                                                      \textit{option list}) = \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [, \textit{texte}]\footnotemark\\
  \> ... \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [, \textit{texte}] \\
  \\
  \textit{comportement\_enum} ::\= = \= \textbf{\tt UnknownVal} \textit{Constructor} \\
  \> $\vert$ \> \textbf{\tt Exception} \textit{Exception}
\end{tabbing}
\shorthandon{:}
\footnotetext{Ce texte sera renvoyé par \texttt{string\_of\_enum} pour
  cette valeur de l'énumération.  Si aucun texte n'est donné, le nom
  du constructeur sera utilisé automatiquement à la place.}


\subsection{Structures, unions et alias}

\shorthandoff{:}
\begin{tabbing}
  \textit{structure} ::= \= \textbf{\tt struct} \= \textit{identifiant} [\textit{option list}] = \{ \\
  \> \> [\textbf{\tt optional}] \textit{identifiant} : \textit{\FAceSLType}; \\
  \> \> ... \\
  \> \> [\textbf{\tt optional}] \textit{identifiant} : \textit{\FAceSLType} \\
  \> \} \\
  \\
  \textit{union} ::= \textbf{\tt union} \= \textit{identifiant} (\textit{comportement\_union}, [\textit{option list}]) = \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \> ... \\
  \> $\vert$ \textit{motif} $\rightarrow$ \textit{Constructeur} [\textbf{\tt of} \textit{\FAceSLType}] \\
  \\
  \textit{comportement\_union} ::\= = \= \textit{Constructor} \\
  \> $\vert$ \> \textit{Constructor} \textbf{\tt of} \textit{\FAceSLType} \\
  \\
  \textit{alias} ::= \textbf{\tt alias} \textit{identifiant} = \textit{\FAceSLType}
\end{tabbing}
\shorthandon{:}

% Structures
%
% L'option \texttt{with\_lwt} déclenche la génération de la fonction
% \texttt{lwt\_parse}. L'option \texttt{with\_exact} permet de créer une
% fonction \texttt{exact\_parse} qui vérifie que la chaîne de caractères
% fournie en entrée correspond exactement à l'objet disséqué et qu'il
% n'existe pas d'octets à la fin de la chaîne de caractères. L'option
% \texttt{top} est un raccourci pour les deux options précédentes,
% puisqu'elle décrit un objet au niveau le plus haut. Enfin, il est
% possible d'ajouter des paramètres aux fonctions \texttt{parse} et
% \texttt{dump} générées avec l'option \texttt{param}; ces paramètres
% pourront être utilisés dans les expressions entre parenthèses (pour
% indiquer une longueur ou pour transmettre un argument à un type
% personnalisé), comme nous le verrons dans le prochain exemple.
%
%
%
% Unions
%
% \footnote{Il est possible de spécifier un autre
%   \FAceSLType pour le constructeur par défaut en le spécifiant dans le
%   comportement.}
%
% Si on ne souhaite pas enrichir l'union ou que le discriminant n'a pas
% une valeur attendue, on utilise le constructeur par défaut, qui
% récupère par défaut le reste de la chaîne de caractère à
% \emph{parser}.
%
% L'enrichissement de l'union \texttt{u} est contrôlé par une variable
% globale \texttt{enrich\_u}, initialisée à \texttt{true} si l'option
% \texttt{enrich} est activée, à \texttt{false} sinon. De plus, on peut
% surcharger cette valeur par un argument optionnel \texttt{enrich} de
% la fonction \texttt{parse}. Si l'option \texttt{exhaustive} est
% positionnée, le \emph{pattern matching} généré pour l'enrichissement
% sera exclusivement composé des motifs de la description (sans motif
% par défaut «~\texttt{\_}~»).

\subsection{Description des objets ASN.1}

\shorthandoff{:}
\begin{tabbing}
  \textit{ASN1Header} ::= \textit{ASN1Class} \textbf{\tt *} \textit{ASN1Tag} \\
  \\
  \textit{ASN1Type} ::= \textit{ASN1Header} \texttt{option} \textbf{\tt *}
                        \textit{ASN1TypeContent} \\
  \\
  \textit{ASN1TypeContent} ::\= = \= \textbf{\tt asn1\_bool} \\
  \> $\vert$ \> \textbf{\tt asn1\_integer} \\
  \> $\vert$ \> \textbf{\tt asn1\_bitstring} \\
  \> $\vert$ \> \textbf{\tt asn1\_enumerated} \\
  \> $\vert$ \> \textbf{\tt asn1\_octetstring} \\
  \> $\vert$ \> \textbf{\tt asn1\_null} \\
  \> $\vert$ \> \textbf{\tt asn1\_oid} \\
  \> $\vert$ \> \textbf{\tt asn1\_list} \textbf{\tt of} \textit{ASN1Type} \\
  \> $\vert$ \> \textbf{\tt asn1\_container} \textbf{\tt of} \textit{ASN1Type} \\
  \> $\vert$ \> \textbf{\tt asn1\_anything} \\
  \> $\vert$ \> \textit{custom type} \\
  \> $\vert$ \> \textit{custom type} (\textit{paramètres}) \\
  \\
  \textit{alias\_ASN.1} ::= \textbf{\tt asn1\_alias} \textit{identifiant} = \textit{ASN1Type}
\end{tabbing}
\shorthandon{:}

% Les premiers \textit{ASN1TypeContents} décrivent le contenu des objets
% ASN.1 classiques: booléens, entiers, chaînes de bit ou d'octets, OIds,
% etc. Le type \texttt{asn1\_enumerated} correspond à un cas particulier
% des chaînes de bit pour représenter un \texttt{bitmap} (par exemple,
% le \emph{KeyUsage} X.509). Le conteneur permet d'encapsuler facilement
% un type ASN.1 dans un objet ASN.1 de type construit (on trouve de tels
% conteneurs pour encapsuler la version ou les extensions dans un
% certificat X.509).

% Pour chaque type de base \texttt{T}, les fonctions
% \texttt{parse\_T\_content}, \texttt{dump\_T\_content} et
% \texttt{print\_T\_content} sont déjà fournies et permettent de traiter
% le contenu de ces types. Des fonctions plus haut niveau, simplement
% nommée \texttt{parse\_T}, \texttt{dump\_T} et \texttt{print\_T}
% prennent en compte l'en-tête ASN.1 par défaut. De plus, des fonctions
% permettent respectivement de \emph{parser} et de \emph{dumper} des
% objets ASN.1 à partir d'un en-tête et d'un type contenu:
% \begin{lstlisting}
% val parse_asn1_object : ?name:string -> asn1_header ->
%                         (string_input -> 'a) -> string_input -> 'a
% val dump_asn1_object : asn1_header -> bool ->
%                        ('a -> string) -> 'a -> string
% \end{lstlisting}

% Pour que cette représentation des types ASN.1 soit complète, il
% faudrait pouvoir ajouter des contraintes sur les champs de bits
% d'énumération ou sur les chaînes de caractères
% (\texttt{PrintableString}, \texttt{UTF8String}, etc.).


% \subsection{Alias ASN.1}

% Les structures ASN.1 peuvent s'exprimer simplement à l'aide des
% structures binaires avec des types ASN.1. Cependant, de telles
% structures ne décrivent que le contenu de l'objet. Pour finaliser la
% description de ces objets, il est nécessaire de leur associer un
% en-tête par défaut. C'est à cela que sert la contruction
% \texttt{asn1\_alias}.

% \shorthandoff{:}
% \begin{tabbing}
%   \textit{alias} ::= \textbf{\tt asn1\_alias} \textit{identifiant} = \textit{ASN1Type} \\
% \end{tabbing}
% \shorthandon{:}

% Ainsi la description d'un objet ASN.1 ressemblera à l'exemple suivant
% (la description d'une clé privée RSA):
% \begin{lstlisting}
% struct private_rsa_key_content = {
%   version : asn1_integer;
%   modulus : asn1_integer;
%   publicExponent : asn1_integer;
%   privateExponent : asn1_integer;
%   prime1 : asn1_integer;
%   prime2 : asn1_integer;
%   exponent1 : asn1_integer;
%   exponent2 : asn1_integer;
%   coefficient : asn1_integer;
% }

% asn1_alias private_rsa_key = (C_Universal, T_Sequence), private_rsa_key_content
% \end{lstlisting}


% TODO: décrire parse_private_rsa_key avec parse_asn1_object et parse_private_rsa_key_content

% TODO:
%  - unions ASN.1 ?
%  - optional fields in ASN.1 structures ?
%  - AO_EnrichRawString -> pour struct!
%  - AO_EnrichASN1Info
%  - AO_TopLevel


\pagebreak
\thispagestyle{colloquetitle}
\cleardoublepage

% \TODO{Dessins des formats}

% \TODO{Remerciements : EJ, GV, VS, JA, BM? et LD?}


\end{document}

