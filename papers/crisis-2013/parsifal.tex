\documentclass{article}
\usepackage[left=2.5cm,right=2.5cm,top=2cm,bottom=2cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{url}
\usepackage{array}
\usepackage{listings}
\lstset{language=Caml, basicstyle=\scriptsize,
  morekeywords={enum, alias, struct, union,
                asn1_alias,
                UnknownVal, with_lwt, Exception}}


\newcommand{\superscriptOL}[1]{\ensuremath{^{\textrm{#1}}}}
\def\wu{\superscriptOL{*}}
\def\wg{\superscriptOL{\dag}}

\title{Parsifal: writing efficient and robust binary parsers, quickly}
\author{
  \begin{tabular}{c}
    Olivier Levillain\wu\wg \qquad Hervé Debar\wg \qquad Benjamin Morin\wu \\[3mm]
    \footnotesize
    \begin{tabular}{ccc}
      {\wu}ANSSI{\ } & & {\wg}Télécom Sud Paris{\ } \\
      51 boulebard Latour Maubourg & & 9 rue Charles Fourier \\
      Paris, France & & Evry, France \\
      \texttt{first.last@ssi.gouv.fr} & & \texttt{first.last@telecom-sudparis.eu} \\
    \end{tabular}
  \end{tabular}
}
\date{}

\begin{document}

\maketitle

Parsers are pervasive software basic blocks: as soon as a program
needs to communicate with another program or to read a file, a parser
is involved. However, writing robust parsers can be difficult, as is
revealed by the amount of bugs and vulnerabilities related to
programming errors in parsers.  In particular, network analysis tools
can be very complex to implement: for example, the Wireshark project
regularly publishes security patches on its various
dissectors\footnote{Since the beginning of the 2013 year, 29~CVE have
  been published on Wireshark.}.

As security researchers, we need robust tools on which we can
depend. The starting point of Parsifal was a study of large amounts of
SSL data~\cite{acsac2012}. The data collected contained legitimate
SSL~\cite{rfc5246} messages, as well as invalid messages and other
protocols (HTTP, SSH). To face this challenge and extract relevant
information, we wrote several parsers, using different languages,
which resulted in Parsifal, an OCaml-based parsing engine. Writing
parsers and analysing data not only helped us better understand
SSL/TLS, but also X.509~\cite{rfc5280} and
BGP/MRT~\cite{rfc4271,rfc6396}. More recently, we have started
studying Kerberos messages.

The contribution of Parsifal to security is twofold. First we provide
sound tools to analyse complex file formats or network
protocols. Secondly we implement robust detection/sanitization
systems.  The goal of this tutorial is to present Parsifal and to use
it to write a network protocol parser (DNS) and a file format parser
(PNG). The PNG parser will then be used to build a PNG
sanitizer. Alternatively, an X.509 certificate signing request
validator can be implemented.

\medskip

Olivier Levillain is head of the Network and Protocols Laboratory at
the French Network and Information Security Agency (ANSSI). His
current research interests are web browser security, network protocols
(SSL/TLS in particular) and the (in)adequation of programming
languages to security goals. He is currently a PhD student under
Pr. Hervé Debar and Dr. Benjamin Morin's advisory.


\section{Project history}

In 2010, the Electronic Frontier Foundation scanned the Internet to
find out how servers answered on the 443/TCP
port worldwide~\cite{eff-observatory, eckersley-obs1, eckersley-obs2}. We
studied this significant amount of data with custom tools, to gain
thorough insight of the data collected~\cite{acsac2012}.

Our first attempt to write an SSL parser was with the Python language;
it was quickly written and allowed us to extract some
information. However, this implementation was unacceptedly slow. The
second parser was in C++, using templates and object-oriented
programming; its goal was to be flexible and fast. Yet, the code was
hard to debug, and contained too many lines.

So a new version was written, in OCaml: it used a DSL (Domain
  Specific Language) close to Python to describe the structures
to be studied. This third parser was as fast as the previous one, less
error-prone, but still needed a lot of lines to code simple
features. That is why we decided to use a preprocessor to do most of
the work, letting the programmer deal only with what's important:
structure description. This last implementation, Parsifal, has all the
properties expected: efficient and robust parsers, written using few
lines of code.

Our work originally covered X.509 certificates and SSL/TLS messages,
but we soon tried Parsifal on other network protocols (BGP/MRT, DNS,
TCP/IP stack, Kerberos) and on some file formats (TAR, PE, PCAP,
PNG). Some of these parsers are still at an early stage, but one of
the strength of Parsifal is that it is easy to describe part of a
protocol, and focus only on what really needs to be dissected.



\section{Parsifal principle: PTypes}

Parsifal basically allows one to use PTypes, which are OCaml types
augmented by the presence of some manipulation functions: a PType
\texttt{t} is composed of:
\begin{itemize}
\item the corresponding OCaml type \texttt{t};
\item a \texttt{parse\_t} function, to transform a binary
  representation of an object into the type \texttt{t};
\item a \texttt{dump\_t} function, that does the reverse operation,
  that is dumping a binary representation out of a constructed type
  \texttt{t};
\item a \texttt{value\_of\_t} function, to translate a constructed
  type \texttt{t} into an abstract representation, which can then be
  printed, exported as JSON, or analysed using generic functions.
\end{itemize}

PTypes are usually built using new keywords: \texttt{enum},
\texttt{struct}, \texttt{union}, etc. However, when dealing with
unsupported cases, it is also possible to add custom PTypes, by writing
directly the \texttt{t} type and the corresponding functions. A lot of
basic PTypes are already present in the core library.


\subsection{Examples of construction}

Among the TLS messages, alerts are used to signal a problem during the
session. Such messages are simply composed of an alert level (one byte
with two possible values) and an alert type (another byte). An extract
of the specification is given in figure~\ref{fig:tls-spec}. It is
possible to describe such messages in Parsifal with the code given in
figure~\ref{fig:tls-descr}. As a result, the preprocessor will
generate three OCaml types, and some functions, as presented in
figure~\ref{fig:tls-generated-code}.


\begin{figure}[p]
  \begin{center}\begin{minipage}{.35\linewidth}
    {\scriptsize
    \begin{verbatim}
enum { warning(1), fatal(2), (255) } AlertLevel;

enum {
    close_notify(0),
     ...
    unsupported_extension(110),
    (255)
} AlertDescription;

struct {
    AlertLevel level;
    AlertDescription description;
} Alert;
    \end{verbatim}}
  \end{minipage}\end{center}
  \caption{Specification of \texttt{tls\_alert} messages (from RFC~5246~\cite{rfc5246}).}
  \label{fig:tls-spec}
\end{figure}



\begin{figure}[p]
  \begin{center}\begin{minipage}{.56\linewidth}
    \begin{lstlisting}
enum tls_alert_level (8, UnknownVal AL_Unknown) =
  | 1 -> AL_Warning, "Warning"
  | 2 -> AL_Fatal, "Fatal"

enum tls_alert_type (8, UnknownVal AT_Unknown) =
  | 0 -> AT_CloseNotify, "CloseNotify"
  ...
  | 115 -> AT_UnknownPSKIdentity, "UnknownPSKIdentity"

struct tls_alert = {
  alert_level : tls_alert_level;
  alert_type : tls_alert_type
}
    \end{lstlisting}
  \end{minipage}\end{center}
  \caption{Parsifal description of \texttt{tls\_alert} messages.}
  \label{fig:tls-descr}
\end{figure}


\begin{figure}[p]
  \begin{center}\begin{minipage}{.65\linewidth}
    \begin{lstlisting}
(* tls_alert_level *)

type tls_alert_level =
    AL_Warning
  | AL_Fatal
  | AL_Unknown of int

(* Conversion functions to/from int/string *)
val int_of_tls_alert_level : tls_alert_level -> int
val string_of_tls_alert_level : tls_alert_level -> string
val tls_alert_level_of_int : int -> tls_alert_level
val tls_alert_level_of_string : string -> tls_alert_level

(* parse/dump/value_of functions *)
val parse_tls_alert_level : input -> tls_alert_level
val dump_tls_alert_level : output -> tls_alert_level -> unit
val value_of_tls_alert_level : tls_alert_level -> value


(* tls_alert_type *)

type tls_alert_type =
    AT_CloseNotify
  ...
  | AT_Unknown of int

(* 7 functions, similar to those relative to tls_alert_level *)


(* tls_alert *)

type tls_alert = {
  alert_level : tls_alert_level;
  alert_type : tls_alert_type;
}
val parse_tls_alert : input -> tls_alert
val dump_tls_alert : output -> tls_alert -> unit
val value_of_tls_alert : tls_alert -> value
    \end{lstlisting}
  \end{minipage}\end{center}
  \caption{Corresponding OCaml code generated (extracts of the interface).}
  \label{fig:tls-generated-code}
\end{figure}


The constructions available in Parsifal are enumerations
(\texttt{enum} keyword), records (\texttt{struct}), choices allowing
for types depending on a parameter (\texttt{union}), ASN.1 DER
structures and choices (\texttt{asn1\_struct} and
\texttt{asn1\_union}) and aliases (\texttt{alias} and
\texttt{asn1\_alias}).


\subsection{Examples of base PTypes}

Parsifal already understands some basic types: integers, string,
IPv4/IPv6 addresses, lists, arrays, \emph{magic} numbers, and ASN.1 basic
objects.

Moreover, Parsifal provides an abstraction, the containers, allowing
to wrap a PType using some processing. For example,
\texttt{base64\_container} and \texttt{hex\_container} allow to work
with encoded types transparently; \texttt{deflate\_container} and
\texttt{zlib\_container} uncompress the output when parsing and
compress when dumping. Finally, \texttt{pkcs1\_container} are an
elegant way to decrypt the content of a PKCS\#1 value and read the
enclosed type when given the corresponding key during parsing
type\footnote{This proved to be useful to process smoothly Kerberos
  PKINIT messages.}.

The idea of the core library is to provide most of the basic types and
transformations used in protocols and file formats. One of the
advantages of Parsifal is that it is easy to partially implement a
protocol to only interpret the cases of interest. It also allows for a
incremental description of a format.

As our initial goal was to handle a lot of data, including corrupted
messages or data not conforming to the specification, it is possible to
implement either strict parsers or flexible ones. This was useful
for example when dissecting X.509 corrupted fields: an error deep in
the certificate should not necessarily invalidate the whole certificate
nor the TLS message containing it.



\section{Related work}

Parsifal may seem similar to two Python projects:
\texttt{scapy}~\cite{scapy}, a toolbox to parse and forge network
packets and \texttt{hachoir}~\cite{hachoir}, a generic framework for
binary file manipulation library. However, as an OCaml development,
Parsifal allows for better perfomance when compiled to native
binaries. In our experience, it is as efficient as corresponding C
implementations\footnote{For example, the time needed to parse
  certificates is comparable with the \texttt{openssl x509}
  command.}. What's more, OCaml is a well-defined, sound language
which brings some safety guarantees regarding memory management that C
or Python do not.

Other preprocessors and libraries exist in the OCaml environment, but
they do not offer a comprehensive framework to describe complex
structures as Parsifal does. For example, the
\texttt{bitstring}~\cite{bitstring} project adds pattern matching on
bitsrings, which is only a part of the types handled by our tool.



\section{Tutorial goals and outline}

A version of this tutorial has already been taught to teach several
co-workers how to use Parsifal. The overall tutorial was given over a
3-hour session. All the material (this short paper, the slides and the
code snippets) will be available on the GitHub repository.

The tutorial is intended for developpers and researchers who need to
manipulate complex binary file formats or network protocols. The
audience would need a basic background in functional programming
(OCaml language preferably).

There are three main goals for this tutorial:
\begin{itemize}
\item learn to use basic Parsifal constructions;
\item write a simple DNS client;
\item code a PNG sanitizer
\end{itemize}

\noindent
Depending on the audience's interests, the DNS or PNG implementation
could be replaced by an X.509 Certificate Signing Request validator.


\subsection{Parsifal presentation}

As was done in the first part of this document, the tutorial begins
with a brief history of the project, and the motivation for writing
robust and efficient parsers.

Then, the principle behind Parsifal are presented: the PTypes and the
methods to generate them automatically using a preprocessor. This part
can be illustrated by several examples of constructions: how to write
them and what kind of code is generated.


\subsection{Downloading and installing Parsifal}

After this short introduction, the tutorial consists of downloading
Parsifal source code from the public repository on GitHub
(\url{https://github.com/ANSSI-FR/parsifal}), installing it and using
it to write parsers step-by-step.

Members of the audience interested in manipulating on their
computers would have to install the OCaml languages and the libraries
on which Parsifal depends.


\subsection{DNS step-by-step}

The first parser proposed for the tutorial is DNS, which is a rather
simple protocol, but contains some subtleties. That is why it is a
good candidate to begin using Parsifal.

After presenting DNS message formats, the implementation goes as
follows:
\begin{itemize}
\item description of DNS enumerations (record types and classes);
\item first implementation of labels and domains using structures;
\item description of more structures (\texttt{question}, \texttt{rr}
  and the overall \texttt{dns\_message} type);
\begin{itemize}
\item[-] at this point, it is possible to parse and print example
  requests and responses;
\end{itemize}
\item progressive specification of the ressource records (A, CNAME,
  MX) using a union;
\item custom rewrite of labels and domains to handle the compression;
\item implementation of the UDP connexion
\begin{itemize}
\item[-] at this point, it is possible to have a minimalistic DNS client.
\end{itemize}
\end{itemize}


\subsection{PNG step-by-step}

Another example can be written to parse PNG files. The different steps
of the implementation would be:
\begin{itemize}
\item description of the outter structure of the image file
  (essentially a list of chunks);
\begin{itemize}
\item[-] at this point, it is possible to implement a tool printing
  the types of the chunks present in a given file;
\item[-] it is also possible to write a basic PNG filter, rewriting
  the file without the comment chunks (\texttt{tEXt} for example);
\end{itemize}
\item rewrite of the chunk container to automatically generate the
  length and the CRC when dumping the chunk;
\item as for DNS resource records, it is possible to use a union to
  progressively describe the different chunk types, starting with the
  mandatory ones (IHDR, PLTE, IDAT and IEND);
\begin{itemize}
\item[-] at this point, it is possible to write a simple PNG sanitizer
  that combines all IDAT chunks into one, and rewrites the image file
  uncompressed. This way, the compression is handled by
  \texttt{zlib\_container}, a pure OCaml robust implementation, and
  not by the end application, which may embed an out-of-date and
  flawed \texttt{zlib}.
\end{itemize}
\end{itemize}


\subsection{X.509 CSR validation}

Another format that is worth implementing is X.509 Certificate Signing
Request. In 2009, Moxie Marlinspike showed how to get a signed
certificate for the wrong domain by sending a subject containing null
characters~\cite{moxie_nullchar}. In all the cases, it might be useful
to constrain the CSR before it hits the certification authority:
remove useless attributes, check the signature before-hand, clean up
the subject to follow a given policy. Here is how it can be done using
Parsifal:
\begin{itemize}
\item description of the ASN.1 structures corresponding to CSRs;
\begin{itemize}
\item[-] at this point, it is possible to implement a tool printing
  CSRs;
\end{itemize}
\item filter out attributes;
\item add a trivial policy on subjects (only one CN field, no null characters, etc.);
\item check the signature and the size of the key;
\begin{itemize}
\item[-] at this point, it is possible to write a simple X.509 CSR
  validator, that can be used as a gate keeper to validate requests.
\end{itemize}
\end{itemize}





\section{Conclusion}

For our needs, we wrote several parsers to analyse a lot of SSL/TLS
data. As the collected messages were sometimes corrupted or invalid,
standard tools did not allow for sound and robust
dissection. Parsifal, an OCaml-based parsing engine, allowed us to
gain insight into several important protocols. Parsifal also proved to
be versatile and might be useful to the security community to write
efficient and robust binary dissectors.



\section*{Acknowledgment}


The work in this paper has been partially sponsored by the EC 7th
Framework Programme as part of the ICT Vis-Sense project (grant
no. 257497). The authors would like to thank the Applied and
Fundamental Research Division of the French Network and Information
Security Agency (ANSSI) for their comments and suggestions.



\bibliographystyle{unsrt}
\bibliography{biblio,rfc}

\end{document}
